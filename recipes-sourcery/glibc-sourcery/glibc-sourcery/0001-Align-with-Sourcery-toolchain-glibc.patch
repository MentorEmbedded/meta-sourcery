From f1918ebc13d16c4e340446fe1ed535dd7ce0f86a Mon Sep 17 00:00:00 2001
From: Christopher Larson <chris_larson@mentor.com>
Date: Thu, 3 Jun 2021 02:35:05 +0500
Subject: [PATCH] Align with Sourcery toolchain glibc

Signed-off-by: Christopher Larson <chris_larson@mentor.com>
---
 ChangeLog                                  |  47 -
 ChangeLog.csl                              |  57 ++
 NEWS                                       |   5 -
 manual/Makefile                            |   3 +-
 posix/Makefile                             |   3 +-
 posix/PCRE.tests                           |  13 +
 posix/bug-regex28.c                        |  46 +-
 posix/bug-regex37.c                        |  32 -
 posix/bug-regex38.c                        |  32 -
 posix/glob.c                               |  25 +-
 posix/regcomp.c                            | 605 ++++++-------
 posix/regex.c                              |  21 +-
 posix/regex.h                              | 335 +++-----
 posix/regex_internal.c                     | 295 +++----
 posix/regex_internal.h                     | 442 ++++------
 posix/regexec.c                            | 942 ++++++++++-----------
 release-notes-csl.xml                      |  57 ++
 resolv/inet_addr.c                         | 178 ++--
 resolv/nss_dns/dns-host.c                  |  24 +-
 sysdeps/arm/armv7/multiarch/memcpy_impl.S  |  22 +-
 sysdeps/arm/memcpy.S                       |  24 +-
 sysdeps/arm/memmove.S                      |  24 +-
 sysdeps/ieee754/ldbl-96/Makefile           |   5 +-
 sysdeps/ieee754/ldbl-96/e_rem_pio2l.c      |  12 -
 sysdeps/ieee754/ldbl-96/test-sinl-pseudo.c |  41 -
 sysdeps/unix/sysv/linux/if_index.c         |  11 +-
 26 files changed, 1425 insertions(+), 1876 deletions(-)
 create mode 100644 ChangeLog.csl
 delete mode 100644 posix/bug-regex37.c
 delete mode 100644 posix/bug-regex38.c
 create mode 100644 release-notes-csl.xml
 delete mode 100644 sysdeps/ieee754/ldbl-96/test-sinl-pseudo.c

diff --git a/ChangeLog b/ChangeLog
index 019ebf7082..e3593ef343 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,50 +1,3 @@
-2019-01-31  Paul Eggert  <eggert@cs.ucla.edu>
-
-	regex: fix read overrun [BZ #24114]
-	Problem found by AddressSanitizer, reported by Hongxu Chen in:
-	https://debbugs.gnu.org/34140
-	* posix/regexec.c (proceed_next_node):
-	Do not read past end of input buffer.
-
-2019-01-18  Florian Weimer  <fweimer@redhat.com>
-
-	[BZ #24112]
-	resolv: Do not send queries for non-host-names in nss_dns.
-	* resolv/nss_dns/dns-host.c (check_name): New function.
-	(_nss_dns_gethostbyname2_r): Use it.
-	(_nss_dns_gethostbyname_r): Likewise.
-	(_nss_dns_gethostbyname4_r): Likewise.
-
-2019-01-21  Florian Weimer  <fweimer@redhat.com>
-
-	* resolv/inet_addr.c: Reformat to GNU style.
-	(__inet_addr, __inet_aton): Update comment.
-
-2018-11-27  Florian Weimer  <fweimer@redhat.com>
-
-	[BZ #23927]
-	CVE-2018-19591
-	* sysdeps/unix/sysv/linux/if_index.c (__if_nametoindex): Avoid
-	descriptor leak in case of ENODEV error.
-
-2018-07-04  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
-
-	[BZ #23233]
-	[BZ #21163]
-	[BZ #18986]
-	[BZ #13762]
-	* posix/Makefile (tests): Add bug-regex37 and bug-regex38.
-	* posix/PCRE.tests: Remove invalid test.
-	* posix/bug-regex28.c: Fix expected values for used syntax.
-	* posix/bug-regex37.c: New file.
-	* posix/bug-regex38.c: Likewise.
-	* posix/regcomp.c: Sync with gnulib.
-	* posix/regex.c: Likewise.
-	* posix/regex.h: Likewise.
-	* posix/regex_internal.c: Likewise.
-	* posix/regex_internal.h: Likewise.
-	* posix/regexec.c: Likewise.
-
 2018-06-08  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
 
 	[BZ #23264]
diff --git a/ChangeLog.csl b/ChangeLog.csl
new file mode 100644
index 0000000000..b33e248ccb
--- /dev/null
+++ b/ChangeLog.csl
@@ -0,0 +1,57 @@
+2018-03-17  Chung-Lin Tang <cltang@codesourcery.com>
+	    Sandra Loosemore  <sandra@codesourcery.com>
+
+	Apply missing upstream patch.
+
+	* sysdeps/nios2/libm-test-ulps: Update for glibc 2.27.
+
+2018-02-01  Joseph Myers  <joseph@codesourcery.com>
+
+	Merge from SCB glibc 2.26:
+
+	2017-12-06  Paul Carroll  <pcarroll@codesourcery.com>
+
+	ITS-152
+	* sysdeps/nptl/pthread.h:  Added 'volatile' to __cancel_routine
+	and __cancel_arg definitions.
+	* sysdeps/unix/sysv/linux/hppa/pthread.h:  Likewise.
+	* nptl/Makefile: Added tst_clobbered test case.
+	* nptl/tst-clobbered.c: New test case.
+	* release-notes-csl.xml (pthread.h patch): New note.
+
+	Merge from SCB glibc 2.26:
+
+	2017-03-15  Sandra Loosemore  <sandra@codesourcery.com>
+
+	CB-3023
+	* release-notes-csl.xml (AF_BUS support removed): New note.
+
+	Merge from SCB glibc 2.26:
+
+	2015-02-11  James Lemke  <jwlemke@codesourcery.com>
+
+        * Makefiles ($(addprefix
+        $(inst_libdir)/libc_pic/,$(install-extras))): Use $(elf-objpfx)
+        not $(elfobjdir) in dependency.
+
+        Merge from EGLIBC:
+
+        2008-02-07  Joseph Myers  <joseph@codesourcery.com>
+
+        * Makerules (install-extras, install-map): New variables.
+        (installed-libcs): Add libc_pic.a.
+        (install-lib): Include _pic.a files for versioned shared
+        libraries.
+        (install-map-nosubdir, install-extras-nosubdir): Add rules for
+        installing extra files.
+        (install-no-libc.a-nosubdir): Depend on install-map-nosubdir and
+        install-extras-nosubdir.
+
+	Merge from SCB glibc 2.26:
+
+	2015-03-23  Sandra Loosemore  <sandra@codesourcery.com>
+
+        * elf/rtld.c (_dl_start): Zero-initialize the entire bootstrap_map
+        structure.
+
+	* release-notes-csl.xml (GNU C Library version 2.27): New note.
diff --git a/NEWS b/NEWS
index c1730c6b88..2443880321 100644
--- a/NEWS
+++ b/NEWS
@@ -26,10 +26,6 @@ Security related changes:
   architecture could write beyond the target buffer, resulting in a buffer
   overflow.  Reported by Andreas Schwab.
 
-  CVE-2018-19591: A file descriptor leak in if_nametoindex can lead to a
-  denial of service due to resource exhaustion when processing getaddrinfo
-  calls with crafted host names.  Reported by Guido Vranken.
-
 The following bugs are resolved with this release:
 
   [6889] 'PWD' mentioned but not specified
@@ -68,7 +64,6 @@ The following bugs are resolved with this release:
   [23196] __mempcpy_avx512_no_vzeroupper mishandles large copies
   [23236] Harden function pointers in _IO_str_fields
   [23264] libc: posix_spawnp wrongly executes ENOEXEC in non compat mode
-  [23927] Linux if_nametoindex() does not close descriptor (CVE-2018-19591)
 
 
 Version 2.27
diff --git a/manual/Makefile b/manual/Makefile
index 1b5bb16a96..c2756640a7 100644
--- a/manual/Makefile
+++ b/manual/Makefile
@@ -102,8 +102,7 @@ $(objpfx)libm-err.texi: $(objpfx)stamp-libm-err
 $(objpfx)stamp-libm-err: libm-err-tab.pl $(wildcard $(foreach dir,$(sysdirs),\
 						     $(dir)/libm-test-ulps))
 	pwd=`pwd`; \
-	$(PERL) $< $$pwd/../ports > $(objpfx)libm-err-tmp
-	$(PERL) $< $$pwd/../sysdeps >> $(objpfx)libm-err-tmp
+	$(PERL) $< $$pwd/.. > $(objpfx)libm-err-tmp
 	$(move-if-change) $(objpfx)libm-err-tmp $(objpfx)libm-err.texi
 	touch $@
 
diff --git a/posix/Makefile b/posix/Makefile
index 5ea6f70727..0fb280ba69 100644
--- a/posix/Makefile
+++ b/posix/Makefile
@@ -95,8 +95,7 @@ tests		:= test-errno tstgetopt testfnm runtests runptests \
 		   tst-posix_spawn-fd tst-posix_spawn-setsid \
 		   tst-posix_fadvise tst-posix_fadvise64 \
 		   tst-sysconf-empty-chroot tst-glob_symlinks tst-fexecve \
-		   tst-glob-tilde tst-spawn4 bug-regex37 \
-		   bug-regex38
+		   tst-glob-tilde tst-spawn4
 tests-internal	:= bug-regex5 bug-regex20 bug-regex33 \
 		   tst-rfc3484 tst-rfc3484-2 tst-rfc3484-3 \
 		   tst-glob_lstat_compat tst-spawn4-compat
diff --git a/posix/PCRE.tests b/posix/PCRE.tests
index da63b86637..0fb9cadafc 100644
--- a/posix/PCRE.tests
+++ b/posix/PCRE.tests
@@ -1774,6 +1774,19 @@ No match
  0: abcabc
  1: abc
 
+/(a)|\1/
+    a
+ 0: a
+ 1: a
+    *** Failers
+ 0: a
+ 1: a
+    ab
+ 0: a
+ 1: a
+    x
+No match
+
 /abc/i
     ABC
  0: ABC
diff --git a/posix/bug-regex28.c b/posix/bug-regex28.c
index ba263b27c8..5353edf373 100644
--- a/posix/bug-regex28.c
+++ b/posix/bug-regex28.c
@@ -21,22 +21,18 @@
 #include <stdio.h>
 #include <string.h>
 
-#include <support/test-driver.h>
-#include <support/check.h>
-
 struct tests
 {
   const char *regex;
   const char *string;
   reg_syntax_t syntax;
   int retval;
-};
-static const struct tests tests[] = {
+} tests[] = {
 #define EGREP RE_SYNTAX_EGREP
 #define EGREP_NL (RE_SYNTAX_EGREP | RE_DOT_NEWLINE) & ~RE_HAT_LISTS_NOT_NEWLINE
-  { "a.b", "a\nb", EGREP, 0 },
+  { "a.b", "a\nb", EGREP, -1 },
   { "a.b", "a\nb", EGREP_NL, 0 },
-  { "a[^x]b", "a\nb", EGREP, 0 },
+  { "a[^x]b", "a\nb", EGREP, -1 },
   { "a[^x]b", "a\nb", EGREP_NL, 0 },
   /* While \S and \W are internally handled as [^[:space:]] and [^[:alnum:]_],
      RE_HAT_LISTS_NOT_NEWLINE did not make any difference, so ensure
@@ -46,33 +42,33 @@ static const struct tests tests[] = {
   { "a\\Wb", "a\nb", EGREP, 0 },
   { "a\\Wb", "a\nb", EGREP_NL, 0 }
 };
-static const size_t tests_size = sizeof (tests) / sizeof (tests[0]);
 
-static int
-do_test (void)
+int
+main (void)
 {
   struct re_pattern_buffer r;
+  size_t i;
+  int ret = 0;
 
-  for (size_t i = 0; i < tests_size; i++)
+  for (i = 0; i < sizeof (tests) / sizeof (tests[i]); ++i)
     {
       re_set_syntax (tests[i].syntax);
       memset (&r, 0, sizeof (r));
-      const char *re = re_compile_pattern (tests[i].regex,
-					   strlen (tests[i].regex), &r);
-      TEST_VERIFY (re == NULL);
-      if (re != NULL)
-        continue;
-
+      if (re_compile_pattern (tests[i].regex, strlen (tests[i].regex), &r))
+	{
+	  printf ("re_compile_pattern %zd failed\n", i);
+	  ret = 1;
+	  continue;
+	}
       size_t len = strlen (tests[i].string);
       int rv = re_search (&r, tests[i].string, len, 0, len, NULL);
-      TEST_VERIFY (rv == tests[i].retval);
-      if (test_verbose > 0)
-        printf ("info: i=%zu rv=%d expected=%d\n", i, rv, tests[i].retval);
-
+      if (rv != tests[i].retval)
+	{
+	  printf ("re_search %zd unexpected value %d != %d\n",
+		  i, rv, tests[i].retval);
+	  ret = 1;
+	}
       regfree (&r);
     }
-
-  return 0;
+  return ret;
 }
-
-#include <support/test-driver.c>
diff --git a/posix/bug-regex37.c b/posix/bug-regex37.c
deleted file mode 100644
index 87a0916914..0000000000
--- a/posix/bug-regex37.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Test regcomp return for invalid expression (BZ #21163).
-   Copyright (C) 2018 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <regex.h>
-
-#include <support/check.h>
-
-static int
-do_test (void)
-{
-  char const pattern[] = "()*)|\\1)*";
-  regex_t r;
-  TEST_VERIFY_EXIT (regcomp (&r, pattern, REG_EXTENDED) == REG_ESUBREG);
-  return 0;
-}
-
-#include <support/test-driver.c>
diff --git a/posix/bug-regex38.c b/posix/bug-regex38.c
deleted file mode 100644
index cb0eb7d214..0000000000
--- a/posix/bug-regex38.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Diagnose invalid back-reference in the ERE '()|\1' (BZ #18986).
-   Copyright (C) 2018 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <regex.h>
-
-#include <support/check.h>
-
-static int
-do_test (void)
-{
-  char const pattern[] = "0|()0|\\1|0";
-  regex_t r;
-  TEST_VERIFY_EXIT (regcomp (&r, pattern, REG_EXTENDED) == REG_ESUBREG);
-  return 0;
-}
-
-#include <support/test-driver.c>
diff --git a/posix/glob.c b/posix/glob.c
index 1b389d2da1..8444b2f79e 100644
--- a/posix/glob.c
+++ b/posix/glob.c
@@ -827,32 +827,31 @@ __glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
 	      {
 		size_t home_len = strlen (p->pw_dir);
 		size_t rest_len = end_name == NULL ? 0 : strlen (end_name);
-		char *d, *newp;
-		bool use_alloca = glob_use_alloca (alloca_used,
-						   home_len + rest_len + 1);
+		char *d;
 
-		if (use_alloca)
-		  newp = alloca_account (home_len + rest_len + 1, alloca_used);
+		if (__glibc_unlikely (malloc_dirname))
+		  free (dirname);
+		malloc_dirname = 0;
+
+		if (glob_use_alloca (alloca_used, home_len + rest_len + 1))
+		  dirname = alloca_account (home_len + rest_len + 1,
+					    alloca_used);
 		else
 		  {
-		    newp = malloc (home_len + rest_len + 1);
-		    if (newp == NULL)
+		    dirname = malloc (home_len + rest_len + 1);
+		    if (dirname == NULL)
 		      {
 			scratch_buffer_free (&pwtmpbuf);
 			retval = GLOB_NOSPACE;
 			goto out;
 		      }
+		    malloc_dirname = 1;
 		  }
-		d = mempcpy (newp, p->pw_dir, home_len);
+		d = mempcpy (dirname, p->pw_dir, home_len);
 		if (end_name != NULL)
 		  d = mempcpy (d, end_name, rest_len);
 		*d = '\0';
 
-		if (__glibc_unlikely (malloc_dirname))
-		  free (dirname);
-		dirname = newp;
-		malloc_dirname = !use_alloca;
-
 		dirlen = home_len + rest_len;
 		dirname_modified = 1;
 	      }
diff --git a/posix/regcomp.c b/posix/regcomp.c
index 7b5ddaad0c..f5c09febb9 100644
--- a/posix/regcomp.c
+++ b/posix/regcomp.c
@@ -15,7 +15,9 @@
 
    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdint.h>
 
 #ifdef _LIBC
 # include <locale/weight.h>
@@ -49,14 +51,14 @@ static bin_tree_t *lower_subexp (reg_errcode_t *err, regex_t *preg,
 static reg_errcode_t calc_first (void *extra, bin_tree_t *node);
 static reg_errcode_t calc_next (void *extra, bin_tree_t *node);
 static reg_errcode_t link_nfa_nodes (void *extra, bin_tree_t *node);
-static Idx duplicate_node (re_dfa_t *dfa, Idx org_idx, unsigned int constraint);
-static Idx search_duplicated_node (const re_dfa_t *dfa, Idx org_node,
+static int duplicate_node (re_dfa_t *dfa, int org_idx, unsigned int constraint);
+static int search_duplicated_node (const re_dfa_t *dfa, int org_node,
 				   unsigned int constraint);
 static reg_errcode_t calc_eclosure (re_dfa_t *dfa);
 static reg_errcode_t calc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa,
-					 Idx node, bool root);
+					 int node, int root);
 static reg_errcode_t calc_inveclosure (re_dfa_t *dfa);
-static Idx fetch_number (re_string_t *input, re_token_t *token,
+static int fetch_number (re_string_t *input, re_token_t *token,
 			 reg_syntax_t syntax);
 static int peek_token (re_token_t *token, re_string_t *input,
 			reg_syntax_t syntax);
@@ -64,16 +66,16 @@ static bin_tree_t *parse (re_string_t *regexp, regex_t *preg,
 			  reg_syntax_t syntax, reg_errcode_t *err);
 static bin_tree_t *parse_reg_exp (re_string_t *regexp, regex_t *preg,
 				  re_token_t *token, reg_syntax_t syntax,
-				  Idx nest, reg_errcode_t *err);
+				  int nest, reg_errcode_t *err);
 static bin_tree_t *parse_branch (re_string_t *regexp, regex_t *preg,
 				 re_token_t *token, reg_syntax_t syntax,
-				 Idx nest, reg_errcode_t *err);
+				 int nest, reg_errcode_t *err);
 static bin_tree_t *parse_expression (re_string_t *regexp, regex_t *preg,
 				     re_token_t *token, reg_syntax_t syntax,
-				     Idx nest, reg_errcode_t *err);
+				     int nest, reg_errcode_t *err);
 static bin_tree_t *parse_sub_exp (re_string_t *regexp, regex_t *preg,
 				  re_token_t *token, reg_syntax_t syntax,
-				  Idx nest, reg_errcode_t *err);
+				  int nest, reg_errcode_t *err);
 static bin_tree_t *parse_dup_op (bin_tree_t *dup_elem, re_string_t *regexp,
 				 re_dfa_t *dfa, re_token_t *token,
 				 reg_syntax_t syntax, reg_errcode_t *err);
@@ -85,34 +87,34 @@ static reg_errcode_t parse_bracket_element (bracket_elem_t *elem,
 					    re_token_t *token, int token_len,
 					    re_dfa_t *dfa,
 					    reg_syntax_t syntax,
-					    bool accept_hyphen);
+					    int accept_hyphen);
 static reg_errcode_t parse_bracket_symbol (bracket_elem_t *elem,
 					  re_string_t *regexp,
 					  re_token_t *token);
 #ifdef RE_ENABLE_I18N
 static reg_errcode_t build_equiv_class (bitset_t sbcset,
 					re_charset_t *mbcset,
-					Idx *equiv_class_alloc,
+					int *equiv_class_alloc,
 					const unsigned char *name);
 static reg_errcode_t build_charclass (RE_TRANSLATE_TYPE trans,
 				      bitset_t sbcset,
 				      re_charset_t *mbcset,
-				      Idx *char_class_alloc,
-				      const char *class_name,
+				      int *char_class_alloc,
+				      const unsigned char *class_name,
 				      reg_syntax_t syntax);
 #else  /* not RE_ENABLE_I18N */
 static reg_errcode_t build_equiv_class (bitset_t sbcset,
 					const unsigned char *name);
 static reg_errcode_t build_charclass (RE_TRANSLATE_TYPE trans,
 				      bitset_t sbcset,
-				      const char *class_name,
+				      const unsigned char *class_name,
 				      reg_syntax_t syntax);
 #endif /* not RE_ENABLE_I18N */
 static bin_tree_t *build_charclass_op (re_dfa_t *dfa,
 				       RE_TRANSLATE_TYPE trans,
-				       const char *class_name,
-				       const char *extra,
-				       bool non_match, reg_errcode_t *err);
+				       const unsigned char *class_name,
+				       const unsigned char *extra,
+				       int non_match, reg_errcode_t *err);
 static bin_tree_t *create_tree (re_dfa_t *dfa,
 				bin_tree_t *left, bin_tree_t *right,
 				re_token_type_t type);
@@ -129,7 +131,7 @@ static reg_errcode_t mark_opt_subexp (void *extra, bin_tree_t *node);
    POSIX doesn't require that we do anything for REG_NOERROR,
    but why not be nice?  */
 
-static const char __re_error_msgid[] =
+const char __re_error_msgid[] attribute_hidden =
   {
 #define REG_NOERROR_IDX	0
     gettext_noop ("Success")	/* REG_NOERROR */
@@ -153,9 +155,9 @@ static const char __re_error_msgid[] =
     gettext_noop ("Invalid back reference") /* REG_ESUBREG */
     "\0"
 #define REG_EBRACK_IDX	(REG_ESUBREG_IDX + sizeof "Invalid back reference")
-    gettext_noop ("Unmatched [, [^, [:, [., or [=")	/* REG_EBRACK */
+    gettext_noop ("Unmatched [ or [^")	/* REG_EBRACK */
     "\0"
-#define REG_EPAREN_IDX	(REG_EBRACK_IDX + sizeof "Unmatched [, [^, [:, [., or [=")
+#define REG_EPAREN_IDX	(REG_EBRACK_IDX + sizeof "Unmatched [ or [^")
     gettext_noop ("Unmatched ( or \\(") /* REG_EPAREN */
     "\0"
 #define REG_EBRACE_IDX	(REG_EPAREN_IDX + sizeof "Unmatched ( or \\(")
@@ -183,7 +185,7 @@ static const char __re_error_msgid[] =
     gettext_noop ("Unmatched ) or \\)") /* REG_ERPAREN */
   };
 
-static const size_t __re_error_msgid_idx[] =
+const size_t __re_error_msgid_idx[] attribute_hidden =
   {
     REG_NOERROR_IDX,
     REG_NOMATCH_IDX,
@@ -267,7 +269,7 @@ weak_alias (__re_set_syntax, re_set_syntax)
 int
 re_compile_fastmap (struct re_pattern_buffer *bufp)
 {
-  re_dfa_t *dfa = bufp->buffer;
+  re_dfa_t *dfa = (re_dfa_t *) bufp->buffer;
   char *fastmap = bufp->fastmap;
 
   memset (fastmap, '\0', sizeof (char) * SBC_MAX);
@@ -301,12 +303,12 @@ static void
 re_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,
 			 char *fastmap)
 {
-  re_dfa_t *dfa = bufp->buffer;
-  Idx node_cnt;
-  bool icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));
+  re_dfa_t *dfa = (re_dfa_t *) bufp->buffer;
+  int node_cnt;
+  int icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));
   for (node_cnt = 0; node_cnt < init_state->nodes.nelem; ++node_cnt)
     {
-      Idx node = init_state->nodes.elems[node_cnt];
+      int node = init_state->nodes.elems[node_cnt];
       re_token_type_t type = dfa->nodes[node].type;
 
       if (type == CHARACTER)
@@ -315,8 +317,7 @@ re_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,
 #ifdef RE_ENABLE_I18N
 	  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)
 	    {
-	      unsigned char buf[MB_LEN_MAX];
-	      unsigned char *p;
+	      unsigned char *buf = alloca (dfa->mb_cur_max), *p;
 	      wchar_t wc;
 	      mbstate_t state;
 
@@ -331,7 +332,7 @@ re_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,
 			     &state) == p - buf
 		  && (__wcrtomb ((char *) buf, __towlower (wc), &state)
 		      != (size_t) -1))
-		re_set_fastmap (fastmap, false, buf[0]);
+		re_set_fastmap (fastmap, 0, buf[0]);
 	    }
 #endif
 	}
@@ -351,7 +352,7 @@ re_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,
       else if (type == COMPLEX_BRACKET)
 	{
 	  re_charset_t *cset = dfa->nodes[node].opr.mbcset;
-	  Idx i;
+	  int i;
 
 # ifdef _LIBC
 	  /* See if we have to try all bytes which start multiple collation
@@ -464,7 +465,7 @@ re_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,
    the return codes and their meanings.)  */
 
 int
-regcomp (regex_t *_Restrict_ preg, const char *_Restrict_ pattern, int cflags)
+regcomp (regex_t *__restrict preg, const char *__restrict pattern, int cflags)
 {
   reg_errcode_t ret;
   reg_syntax_t syntax = ((cflags & REG_EXTENDED) ? RE_SYNTAX_POSIX_EXTENDED
@@ -524,7 +525,7 @@ weak_alias (__regcomp, regcomp)
    from either regcomp or regexec.   We don't use PREG here.  */
 
 size_t
-regerror (int errcode, const regex_t *_Restrict_ preg, char *_Restrict_ errbuf,
+regerror (int errcode, const regex_t *__restrict preg, char *__restrict errbuf,
 	  size_t errbuf_size)
 {
   const char *msg;
@@ -545,13 +546,17 @@ regerror (int errcode, const regex_t *_Restrict_ preg, char *_Restrict_ errbuf,
 
   if (BE (errbuf_size != 0, 1))
     {
-      size_t cpy_size = msg_size;
       if (BE (msg_size > errbuf_size, 0))
 	{
-	  cpy_size = errbuf_size - 1;
-	  errbuf[cpy_size] = '\0';
+#if defined HAVE_MEMPCPY || defined _LIBC
+	  *((char *) __mempcpy (errbuf, msg, errbuf_size - 1)) = '\0';
+#else
+	  memcpy (errbuf, msg, errbuf_size - 1);
+	  errbuf[errbuf_size - 1] = 0;
+#endif
 	}
-      memcpy (errbuf, msg, cpy_size);
+      else
+	memcpy (errbuf, msg, msg_size);
     }
 
   return msg_size;
@@ -569,23 +574,7 @@ weak_alias (__regerror, regerror)
 static const bitset_t utf8_sb_map =
 {
   /* Set the first 128 bits.  */
-# if defined __GNUC__ && !defined __STRICT_ANSI__
   [0 ... 0x80 / BITSET_WORD_BITS - 1] = BITSET_WORD_MAX
-# else
-#  if 4 * BITSET_WORD_BITS < ASCII_CHARS
-#   error "bitset_word_t is narrower than 32 bits"
-#  elif 3 * BITSET_WORD_BITS < ASCII_CHARS
-  BITSET_WORD_MAX, BITSET_WORD_MAX, BITSET_WORD_MAX,
-#  elif 2 * BITSET_WORD_BITS < ASCII_CHARS
-  BITSET_WORD_MAX, BITSET_WORD_MAX,
-#  elif 1 * BITSET_WORD_BITS < ASCII_CHARS
-  BITSET_WORD_MAX,
-#  endif
-  (BITSET_WORD_MAX
-   >> (SBC_MAX % BITSET_WORD_BITS == 0
-       ? 0
-       : BITSET_WORD_BITS - SBC_MAX % BITSET_WORD_BITS))
-# endif
 };
 #endif
 
@@ -593,7 +582,7 @@ static const bitset_t utf8_sb_map =
 static void
 free_dfa_content (re_dfa_t *dfa)
 {
-  Idx i, j;
+  int i, j;
 
   if (dfa->nodes)
     for (i = 0; i < dfa->nodes_len; ++i)
@@ -643,12 +632,9 @@ free_dfa_content (re_dfa_t *dfa)
 void
 regfree (regex_t *preg)
 {
-  re_dfa_t *dfa = preg->buffer;
+  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
   if (BE (dfa != NULL, 1))
-    {
-      lock_fini (dfa->lock);
-      free_dfa_content (dfa);
-    }
+    free_dfa_content (dfa);
   preg->buffer = NULL;
   preg->allocated = 0;
 
@@ -701,7 +687,7 @@ re_comp (const char *s)
 
   if (re_comp_buf.fastmap == NULL)
     {
-      re_comp_buf.fastmap = re_malloc (char, SBC_MAX);
+      re_comp_buf.fastmap = (char *) malloc (SBC_MAX);
       if (re_comp_buf.fastmap == NULL)
 	return (char *) gettext (__re_error_msgid
 				 + __re_error_msgid_idx[(int) REG_ESPACE]);
@@ -718,7 +704,7 @@ re_comp (const char *s)
   if (!ret)
     return NULL;
 
-  /* Yes, we're discarding 'const' here if !HAVE_LIBINTL.  */
+  /* Yes, we're discarding `const' here if !HAVE_LIBINTL.  */
   return (char *) gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);
 }
 
@@ -753,7 +739,7 @@ re_compile_internal (regex_t *preg, const char * pattern, size_t length,
   preg->regs_allocated = REGS_UNALLOCATED;
 
   /* Initialize the dfa.  */
-  dfa = preg->buffer;
+  dfa = (re_dfa_t *) preg->buffer;
   if (BE (preg->allocated < sizeof (re_dfa_t), 0))
     {
       /* If zero allocated, but buffer is non-null, try to realloc
@@ -764,13 +750,11 @@ re_compile_internal (regex_t *preg, const char * pattern, size_t length,
       if (dfa == NULL)
 	return REG_ESPACE;
       preg->allocated = sizeof (re_dfa_t);
-      preg->buffer = dfa;
+      preg->buffer = (unsigned char *) dfa;
     }
   preg->used = sizeof (re_dfa_t);
 
   err = init_dfa (dfa, length);
-  if (BE (err == REG_NOERROR && lock_init (dfa->lock) != 0, 0))
-    err = REG_ESPACE;
   if (BE (err != REG_NOERROR, 0))
     {
       free_dfa_content (dfa);
@@ -784,14 +768,15 @@ re_compile_internal (regex_t *preg, const char * pattern, size_t length,
   strncpy (dfa->re_str, pattern, length + 1);
 #endif
 
+  __libc_lock_init (dfa->lock);
+
   err = re_string_construct (&regexp, pattern, length, preg->translate,
-			     (syntax & RE_ICASE) != 0, dfa);
+			     syntax & RE_ICASE, dfa);
   if (BE (err != REG_NOERROR, 0))
     {
     re_compile_internal_free_return:
       free_workarea_compile (preg);
       re_string_destruct (&regexp);
-      lock_fini (dfa->lock);
       free_dfa_content (dfa);
       preg->buffer = NULL;
       preg->allocated = 0;
@@ -824,7 +809,6 @@ re_compile_internal (regex_t *preg, const char * pattern, size_t length,
 
   if (BE (err != REG_NOERROR, 0))
     {
-      lock_fini (dfa->lock);
       free_dfa_content (dfa);
       preg->buffer = NULL;
       preg->allocated = 0;
@@ -839,32 +823,18 @@ re_compile_internal (regex_t *preg, const char * pattern, size_t length,
 static reg_errcode_t
 init_dfa (re_dfa_t *dfa, size_t pat_len)
 {
-  __re_size_t table_size;
+  unsigned int table_size;
 #ifndef _LIBC
-  const char *codeset_name;
+  char *codeset_name;
 #endif
-#ifdef RE_ENABLE_I18N
-  size_t max_i18n_object_size = MAX (sizeof (wchar_t), sizeof (wctype_t));
-#else
-  size_t max_i18n_object_size = 0;
-#endif
-  size_t max_object_size =
-    MAX (sizeof (struct re_state_table_entry),
-	 MAX (sizeof (re_token_t),
-	      MAX (sizeof (re_node_set),
-		   MAX (sizeof (regmatch_t),
-			max_i18n_object_size))));
 
   memset (dfa, '\0', sizeof (re_dfa_t));
 
   /* Force allocation of str_tree_storage the first time.  */
   dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;
 
-  /* Avoid overflows.  The extra "/ 2" is for the table_size doubling
-     calculation below, and for similar doubling calculations
-     elsewhere.  And it's <= rather than <, because some of the
-     doubling calculations add 1 afterwards.  */
-  if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) / 2 <= pat_len, 0))
+  /* Avoid overflows.  */
+  if (pat_len == SIZE_MAX)
     return REG_ESPACE;
 
   dfa->nodes_alloc = pat_len + 1;
@@ -886,11 +856,22 @@ init_dfa (re_dfa_t *dfa, size_t pat_len)
   dfa->map_notascii = (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_MAP_TO_NONASCII)
 		       != 0);
 #else
+# ifdef HAVE_LANGINFO_CODESET
   codeset_name = nl_langinfo (CODESET);
-  if ((codeset_name[0] == 'U' || codeset_name[0] == 'u')
-      && (codeset_name[1] == 'T' || codeset_name[1] == 't')
-      && (codeset_name[2] == 'F' || codeset_name[2] == 'f')
-      && strcmp (codeset_name + 3 + (codeset_name[3] == '-'), "8") == 0)
+# else
+  codeset_name = getenv ("LC_ALL");
+  if (codeset_name == NULL || codeset_name[0] == '\0')
+    codeset_name = getenv ("LC_CTYPE");
+  if (codeset_name == NULL || codeset_name[0] == '\0')
+    codeset_name = getenv ("LANG");
+  if (codeset_name == NULL)
+    codeset_name = "";
+  else if (strchr (codeset_name, '.') !=  NULL)
+    codeset_name = strchr (codeset_name, '.') + 1;
+# endif
+
+  if (strcasecmp (codeset_name, "UTF-8") == 0
+      || strcasecmp (codeset_name, "UTF8") == 0)
     dfa->is_utf8 = 1;
 
   /* We check exhaustively in the loop below if this charset is a
@@ -939,10 +920,9 @@ init_dfa (re_dfa_t *dfa, size_t pat_len)
 static void
 init_word_char (re_dfa_t *dfa)
 {
-  int i = 0;
-  int j;
-  int ch = 0;
   dfa->word_ops_used = 1;
+  int i = 0;
+  int ch = 0;
   if (BE (dfa->map_notascii == 0, 1))
     {
       /* Avoid uint32_t and uint64_t as some non-GCC platforms lack
@@ -979,7 +959,7 @@ init_word_char (re_dfa_t *dfa)
 
  general_case:
   for (; i < BITSET_WORDS; ++i)
-    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)
+    for (int j = 0; j < BITSET_WORD_BITS; ++j, ++ch)
       if (isalnum (ch) || ch == '_')
 	dfa->word_char[i] |= (bitset_word_t) 1 << j;
 }
@@ -989,7 +969,7 @@ init_word_char (re_dfa_t *dfa)
 static void
 free_workarea_compile (regex_t *preg)
 {
-  re_dfa_t *dfa = preg->buffer;
+  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
   bin_tree_storage_t *storage, *next;
   for (storage = dfa->str_tree_storage; storage; storage = next)
     {
@@ -1008,7 +988,7 @@ free_workarea_compile (regex_t *preg)
 static reg_errcode_t
 create_initial_state (re_dfa_t *dfa)
 {
-  Idx first, i;
+  int first, i;
   reg_errcode_t err;
   re_node_set init_nodes;
 
@@ -1027,10 +1007,10 @@ create_initial_state (re_dfa_t *dfa)
   if (dfa->nbackref > 0)
     for (i = 0; i < init_nodes.nelem; ++i)
       {
-	Idx node_idx = init_nodes.elems[i];
+	int node_idx = init_nodes.elems[i];
 	re_token_type_t type = dfa->nodes[node_idx].type;
 
-	Idx clexp_idx;
+	int clexp_idx;
 	if (type != OP_BACK_REF)
 	  continue;
 	for (clexp_idx = 0; clexp_idx < init_nodes.nelem; ++clexp_idx)
@@ -1046,13 +1026,14 @@ create_initial_state (re_dfa_t *dfa)
 
 	if (type == OP_BACK_REF)
 	  {
-	    Idx dest_idx = dfa->edests[node_idx].elems[0];
+	    int dest_idx = dfa->edests[node_idx].elems[0];
 	    if (!re_node_set_contains (&init_nodes, dest_idx))
 	      {
-		reg_errcode_t merge_err
-                  = re_node_set_merge (&init_nodes, dfa->eclosures + dest_idx);
-		if (merge_err != REG_NOERROR)
-		  return merge_err;
+		reg_errcode_t err = re_node_set_merge (&init_nodes,
+						       dfa->eclosures
+						       + dest_idx);
+		if (err != REG_NOERROR)
+		  return err;
 		i = 0;
 	      }
 	  }
@@ -1093,17 +1074,14 @@ create_initial_state (re_dfa_t *dfa)
 static void
 optimize_utf8 (re_dfa_t *dfa)
 {
-  Idx node;
-  int i;
-  bool mb_chars = false;
-  bool has_period = false;
+  int node, i, mb_chars = 0, has_period = 0;
 
   for (node = 0; node < dfa->nodes_len; ++node)
     switch (dfa->nodes[node].type)
       {
       case CHARACTER:
-	if (dfa->nodes[node].opr.c >= ASCII_CHARS)
-	  mb_chars = true;
+	if (dfa->nodes[node].opr.c >= 0x80)
+	  mb_chars = 1;
 	break;
       case ANCHOR:
 	switch (dfa->nodes[node].opr.ctx_type)
@@ -1121,7 +1099,7 @@ optimize_utf8 (re_dfa_t *dfa)
 	  }
 	break;
       case OP_PERIOD:
-	has_period = true;
+	has_period = 1;
 	break;
       case OP_BACK_REF:
       case OP_ALT:
@@ -1133,18 +1111,11 @@ optimize_utf8 (re_dfa_t *dfa)
       case COMPLEX_BRACKET:
 	return;
       case SIMPLE_BRACKET:
-	/* Just double check.  */
-	{
-	  int rshift = (ASCII_CHARS % BITSET_WORD_BITS == 0
-			? 0
-			: BITSET_WORD_BITS - ASCII_CHARS % BITSET_WORD_BITS);
-	  for (i = ASCII_CHARS / BITSET_WORD_BITS; i < BITSET_WORDS; ++i)
-	    {
-	      if (dfa->nodes[node].opr.sbcset[i] >> rshift != 0)
-		return;
-	      rshift = 0;
-	    }
-	}
+	/* Just double check.  The non-ASCII range starts at 0x80.  */
+	assert (0x80 % BITSET_WORD_BITS == 0);
+	for (i = 0x80 / BITSET_WORD_BITS; i < BITSET_WORDS; ++i)
+	  if (dfa->nodes[node].opr.sbcset[i])
+	    return;
 	break;
       default:
 	abort ();
@@ -1154,7 +1125,7 @@ optimize_utf8 (re_dfa_t *dfa)
     for (node = 0; node < dfa->nodes_len; ++node)
       {
 	if (dfa->nodes[node].type == CHARACTER
-	    && dfa->nodes[node].opr.c >= ASCII_CHARS)
+	    && dfa->nodes[node].opr.c >= 0x80)
 	  dfa->nodes[node].mb_partial = 0;
 	else if (dfa->nodes[node].type == OP_PERIOD)
 	  dfa->nodes[node].type = OP_UTF8_PERIOD;
@@ -1173,22 +1144,22 @@ optimize_utf8 (re_dfa_t *dfa)
 static reg_errcode_t
 analyze (regex_t *preg)
 {
-  re_dfa_t *dfa = preg->buffer;
+  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
   reg_errcode_t ret;
 
   /* Allocate arrays.  */
-  dfa->nexts = re_malloc (Idx, dfa->nodes_alloc);
-  dfa->org_indices = re_malloc (Idx, dfa->nodes_alloc);
+  dfa->nexts = re_malloc (int, dfa->nodes_alloc);
+  dfa->org_indices = re_malloc (int, dfa->nodes_alloc);
   dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);
   dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);
   if (BE (dfa->nexts == NULL || dfa->org_indices == NULL || dfa->edests == NULL
 	  || dfa->eclosures == NULL, 0))
     return REG_ESPACE;
 
-  dfa->subexp_map = re_malloc (Idx, preg->re_nsub);
+  dfa->subexp_map = re_malloc (int, preg->re_nsub);
   if (dfa->subexp_map != NULL)
     {
-      Idx i;
+      int i;
       for (i = 0; i < preg->re_nsub; i++)
 	dfa->subexp_map[i] = i;
       preorder (dfa->str_tree, optimize_subexps, dfa);
@@ -1197,7 +1168,7 @@ analyze (regex_t *preg)
 	  break;
       if (i == preg->re_nsub)
 	{
-	  re_free (dfa->subexp_map);
+	  free (dfa->subexp_map);
 	  dfa->subexp_map = NULL;
 	}
     }
@@ -1313,7 +1284,7 @@ optimize_subexps (void *extra, bin_tree_t *node)
   else if (node->token.type == SUBEXP
 	   && node->left && node->left->token.type == SUBEXP)
     {
-      Idx other_idx = node->left->token.opr.idx;
+      int other_idx = node->left->token.opr.idx;
 
       node->left = node->left->left;
       if (node->left)
@@ -1321,7 +1292,7 @@ optimize_subexps (void *extra, bin_tree_t *node)
 
       dfa->subexp_map[other_idx] = dfa->subexp_map[node->token.opr.idx];
       if (other_idx < BITSET_WORD_BITS)
-	dfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);
+	  dfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);
     }
 
   return REG_NOERROR;
@@ -1354,7 +1325,7 @@ lower_subexps (void *extra, bin_tree_t *node)
 static bin_tree_t *
 lower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)
 {
-  re_dfa_t *dfa = preg->buffer;
+  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
   bin_tree_t *body = node->left;
   bin_tree_t *op, *cls, *tree1, *tree;
 
@@ -1437,7 +1408,7 @@ static reg_errcode_t
 link_nfa_nodes (void *extra, bin_tree_t *node)
 {
   re_dfa_t *dfa = (re_dfa_t *) extra;
-  Idx idx = node->node_idx;
+  int idx = node->node_idx;
   reg_errcode_t err = REG_NOERROR;
 
   switch (node->token.type)
@@ -1452,7 +1423,7 @@ link_nfa_nodes (void *extra, bin_tree_t *node)
     case OP_DUP_ASTERISK:
     case OP_ALT:
       {
-	Idx left, right;
+	int left, right;
 	dfa->has_plural_match = 1;
 	if (node->left != NULL)
 	  left = node->left->first->node_idx;
@@ -1494,15 +1465,14 @@ link_nfa_nodes (void *extra, bin_tree_t *node)
    to their own constraint.  */
 
 static reg_errcode_t
-duplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,
-			Idx root_node, unsigned int init_constraint)
+duplicate_node_closure (re_dfa_t *dfa, int top_org_node, int top_clone_node,
+			int root_node, unsigned int init_constraint)
 {
-  Idx org_node, clone_node;
-  bool ok;
+  int org_node, clone_node, ret;
   unsigned int constraint = init_constraint;
   for (org_node = top_org_node, clone_node = top_clone_node;;)
     {
-      Idx org_dest, clone_dest;
+      int org_dest, clone_dest;
       if (dfa->nodes[org_node].type == OP_BACK_REF)
 	{
 	  /* If the back reference epsilon-transit, its destination must
@@ -1515,8 +1485,8 @@ duplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,
 	  if (BE (clone_dest == -1, 0))
 	    return REG_ESPACE;
 	  dfa->nexts[clone_node] = dfa->nexts[org_node];
-	  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);
-	  if (BE (! ok, 0))
+	  ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);
+	  if (BE (ret < 0, 0))
 	    return REG_ESPACE;
 	}
       else if (dfa->edests[org_node].nelem == 0)
@@ -1534,12 +1504,12 @@ duplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,
 	  org_dest = dfa->edests[org_node].elems[0];
 	  re_node_set_empty (dfa->edests + clone_node);
 	  /* If the node is root_node itself, it means the epsilon closure
-	     has a loop.  Then tie it to the destination of the root_node.  */
+	     has a loop.   Then tie it to the destination of the root_node.  */
 	  if (org_node == root_node && clone_node != org_node)
 	    {
-	      ok = re_node_set_insert (dfa->edests + clone_node, org_dest);
-	      if (BE (! ok, 0))
-	        return REG_ESPACE;
+	      ret = re_node_set_insert (dfa->edests + clone_node, org_dest);
+	      if (BE (ret < 0, 0))
+		return REG_ESPACE;
 	      break;
 	    }
 	  /* In case the node has another constraint, append it.  */
@@ -1547,8 +1517,8 @@ duplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,
 	  clone_dest = duplicate_node (dfa, org_dest, constraint);
 	  if (BE (clone_dest == -1, 0))
 	    return REG_ESPACE;
-	  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);
-	  if (BE (! ok, 0))
+	  ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);
+	  if (BE (ret < 0, 0))
 	    return REG_ESPACE;
 	}
       else /* dfa->edests[org_node].nelem == 2 */
@@ -1566,8 +1536,8 @@ duplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,
 	      clone_dest = duplicate_node (dfa, org_dest, constraint);
 	      if (BE (clone_dest == -1, 0))
 		return REG_ESPACE;
-	      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);
-	      if (BE (! ok, 0))
+	      ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);
+	      if (BE (ret < 0, 0))
 		return REG_ESPACE;
 	      err = duplicate_node_closure (dfa, org_dest, clone_dest,
 					    root_node, constraint);
@@ -1578,8 +1548,8 @@ duplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,
 	    {
 	      /* There is a duplicated node which satisfies the constraint,
 		 use it to avoid infinite loop.  */
-	      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);
-	      if (BE (! ok, 0))
+	      ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);
+	      if (BE (ret < 0, 0))
 		return REG_ESPACE;
 	    }
 
@@ -1587,8 +1557,8 @@ duplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,
 	  clone_dest = duplicate_node (dfa, org_dest, constraint);
 	  if (BE (clone_dest == -1, 0))
 	    return REG_ESPACE;
-	  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);
-	  if (BE (! ok, 0))
+	  ret = re_node_set_insert (dfa->edests + clone_node, clone_dest);
+	  if (BE (ret < 0, 0))
 	    return REG_ESPACE;
 	}
       org_node = org_dest;
@@ -1600,11 +1570,11 @@ duplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,
 /* Search for a node which is duplicated from the node ORG_NODE, and
    satisfies the constraint CONSTRAINT.  */
 
-static Idx
-search_duplicated_node (const re_dfa_t *dfa, Idx org_node,
+static int
+search_duplicated_node (const re_dfa_t *dfa, int org_node,
 			unsigned int constraint)
 {
-  Idx idx;
+  int idx;
   for (idx = dfa->nodes_len - 1; dfa->nodes[idx].duplicated && idx > 0; --idx)
     {
       if (org_node == dfa->org_indices[idx]
@@ -1618,10 +1588,10 @@ search_duplicated_node (const re_dfa_t *dfa, Idx org_node,
    Return the index of the new node, or -1 if insufficient storage is
    available.  */
 
-static Idx
-duplicate_node (re_dfa_t *dfa, Idx org_idx, unsigned int constraint)
+static int
+duplicate_node (re_dfa_t *dfa, int org_idx, unsigned int constraint)
 {
-  Idx dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);
+  int dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);
   if (BE (dup_idx != -1, 1))
     {
       dfa->nodes[dup_idx].constraint = constraint;
@@ -1637,18 +1607,17 @@ duplicate_node (re_dfa_t *dfa, Idx org_idx, unsigned int constraint)
 static reg_errcode_t
 calc_inveclosure (re_dfa_t *dfa)
 {
-  Idx src, idx;
-  bool ok;
+  int src, idx, ret;
   for (idx = 0; idx < dfa->nodes_len; ++idx)
     re_node_set_init_empty (dfa->inveclosures + idx);
 
   for (src = 0; src < dfa->nodes_len; ++src)
     {
-      Idx *elems = dfa->eclosures[src].elems;
+      int *elems = dfa->eclosures[src].elems;
       for (idx = 0; idx < dfa->eclosures[src].nelem; ++idx)
 	{
-	  ok = re_node_set_insert_last (dfa->inveclosures + elems[idx], src);
-	  if (BE (! ok, 0))
+	  ret = re_node_set_insert_last (dfa->inveclosures + elems[idx], src);
+	  if (BE (ret == -1, 0))
 	    return REG_ESPACE;
 	}
     }
@@ -1661,12 +1630,11 @@ calc_inveclosure (re_dfa_t *dfa)
 static reg_errcode_t
 calc_eclosure (re_dfa_t *dfa)
 {
-  Idx node_idx;
-  bool incomplete;
+  int node_idx, incomplete;
 #ifdef DEBUG
   assert (dfa->nodes_len > 0);
 #endif
-  incomplete = false;
+  incomplete = 0;
   /* For each nodes, calculate epsilon closure.  */
   for (node_idx = 0; ; ++node_idx)
     {
@@ -1676,7 +1644,7 @@ calc_eclosure (re_dfa_t *dfa)
 	{
 	  if (!incomplete)
 	    break;
-	  incomplete = false;
+	  incomplete = 0;
 	  node_idx = 0;
 	}
 
@@ -1688,13 +1656,13 @@ calc_eclosure (re_dfa_t *dfa)
       if (dfa->eclosures[node_idx].nelem != 0)
 	continue;
       /* Calculate epsilon closure of 'node_idx'.  */
-      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, true);
+      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, 1);
       if (BE (err != REG_NOERROR, 0))
 	return err;
 
       if (dfa->eclosures[node_idx].nelem == 0)
 	{
-	  incomplete = true;
+	  incomplete = 1;
 	  re_node_set_free (&eclosure_elem);
 	}
     }
@@ -1704,13 +1672,13 @@ calc_eclosure (re_dfa_t *dfa)
 /* Calculate epsilon closure of NODE.  */
 
 static reg_errcode_t
-calc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)
+calc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, int node, int root)
 {
   reg_errcode_t err;
-  Idx i;
+  int i;
   re_node_set eclosure;
-  bool ok;
-  bool incomplete = false;
+  int ret;
+  int incomplete = 0;
   err = re_node_set_alloc (&eclosure, dfa->edests[node].nelem + 1);
   if (BE (err != REG_NOERROR, 0))
     return err;
@@ -1736,19 +1704,19 @@ calc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)
     for (i = 0; i < dfa->edests[node].nelem; ++i)
       {
 	re_node_set eclosure_elem;
-	Idx edest = dfa->edests[node].elems[i];
-	/* If calculating the epsilon closure of 'edest' is in progress,
+	int edest = dfa->edests[node].elems[i];
+	/* If calculating the epsilon closure of `edest' is in progress,
 	   return intermediate result.  */
 	if (dfa->eclosures[edest].nelem == -1)
 	  {
-	    incomplete = true;
+	    incomplete = 1;
 	    continue;
 	  }
-	/* If we haven't calculated the epsilon closure of 'edest' yet,
+	/* If we haven't calculated the epsilon closure of `edest' yet,
 	   calculate now. Otherwise use calculated epsilon closure.  */
 	if (dfa->eclosures[edest].nelem == 0)
 	  {
-	    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, false);
+	    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, 0);
 	    if (BE (err != REG_NOERROR, 0))
 	      return err;
 	  }
@@ -1762,14 +1730,14 @@ calc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)
 	   the epsilon closure of this node is also incomplete.  */
 	if (dfa->eclosures[edest].nelem == 0)
 	  {
-	    incomplete = true;
+	    incomplete = 1;
 	    re_node_set_free (&eclosure_elem);
 	  }
       }
 
   /* An epsilon closure includes itself.  */
-  ok = re_node_set_insert (&eclosure, node);
-  if (BE (! ok, 0))
+  ret = re_node_set_insert (&eclosure, node);
+  if (BE (ret < 0, 0))
     return REG_ESPACE;
   if (incomplete && !root)
     dfa->eclosures[node].nelem = 0;
@@ -2078,18 +2046,16 @@ peek_token_bracket (re_token_t *token, re_string_t *input, reg_syntax_t syntax)
 	case '.':
 	  token->type = OP_OPEN_COLL_ELEM;
 	  break;
-
 	case '=':
 	  token->type = OP_OPEN_EQUIV_CLASS;
 	  break;
-
 	case ':':
 	  if (syntax & RE_CHAR_CLASSES)
 	    {
 	      token->type = OP_OPEN_CHAR_CLASS;
 	      break;
 	    }
-	  FALLTHROUGH;
+	  /* else fall through.  */
 	default:
 	  token->type = CHARACTER;
 	  token->opr.c = c;
@@ -2133,7 +2099,7 @@ static bin_tree_t *
 parse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,
        reg_errcode_t *err)
 {
-  re_dfa_t *dfa = preg->buffer;
+  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
   bin_tree_t *tree, *eor, *root;
   re_token_t current_token;
   dfa->syntax = syntax;
@@ -2165,11 +2131,10 @@ parse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,
 
 static bin_tree_t *
 parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,
-	       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)
+	       reg_syntax_t syntax, int nest, reg_errcode_t *err)
 {
-  re_dfa_t *dfa = preg->buffer;
+  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
   bin_tree_t *tree, *branch = NULL;
-  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;
   tree = parse_branch (regexp, preg, token, syntax, nest, err);
   if (BE (*err != REG_NOERROR && tree == NULL, 0))
     return NULL;
@@ -2180,8 +2145,6 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,
       if (token->type != OP_ALT && token->type != END_OF_RE
 	  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))
 	{
-	  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;
-	  dfa->completed_bkref_map = initial_bkref_map;
 	  branch = parse_branch (regexp, preg, token, syntax, nest, err);
 	  if (BE (*err != REG_NOERROR && branch == NULL, 0))
 	    {
@@ -2189,7 +2152,6 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,
 		postorder (tree, free_tree, NULL);
 	      return NULL;
 	    }
-	  dfa->completed_bkref_map |= accumulated_bkref_map;
 	}
       else
 	branch = NULL;
@@ -2214,10 +2176,10 @@ parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,
 
 static bin_tree_t *
 parse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,
-	      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)
+	      reg_syntax_t syntax, int nest, reg_errcode_t *err)
 {
-  bin_tree_t *tree, *expr;
-  re_dfa_t *dfa = preg->buffer;
+  bin_tree_t *tree, *exp;
+  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
   tree = parse_expression (regexp, preg, token, syntax, nest, err);
   if (BE (*err != REG_NOERROR && tree == NULL, 0))
     return NULL;
@@ -2225,19 +2187,19 @@ parse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,
   while (token->type != OP_ALT && token->type != END_OF_RE
 	 && (nest == 0 || token->type != OP_CLOSE_SUBEXP))
     {
-      expr = parse_expression (regexp, preg, token, syntax, nest, err);
-      if (BE (*err != REG_NOERROR && expr == NULL, 0))
+      exp = parse_expression (regexp, preg, token, syntax, nest, err);
+      if (BE (*err != REG_NOERROR && exp == NULL, 0))
 	{
 	  if (tree != NULL)
 	    postorder (tree, free_tree, NULL);
 	  return NULL;
 	}
-      if (tree != NULL && expr != NULL)
+      if (tree != NULL && exp != NULL)
 	{
-	  bin_tree_t *newtree = create_tree (dfa, tree, expr, CONCAT);
+	  bin_tree_t *newtree = create_tree (dfa, tree, exp, CONCAT);
 	  if (newtree == NULL)
 	    {
-	      postorder (expr, free_tree, NULL);
+	      postorder (exp, free_tree, NULL);
 	      postorder (tree, free_tree, NULL);
 	      *err = REG_ESPACE;
 	      return NULL;
@@ -2245,8 +2207,8 @@ parse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,
 	  tree = newtree;
 	}
       else if (tree == NULL)
-	tree = expr;
-      /* Otherwise expr == NULL, we don't need to create new tree.  */
+	tree = exp;
+      /* Otherwise exp == NULL, we don't need to create new tree.  */
     }
   return tree;
 }
@@ -2259,9 +2221,9 @@ parse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,
 
 static bin_tree_t *
 parse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,
-		  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)
+		  reg_syntax_t syntax, int nest, reg_errcode_t *err)
 {
-  re_dfa_t *dfa = preg->buffer;
+  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
   bin_tree_t *tree;
   switch (token->type)
     {
@@ -2291,19 +2253,16 @@ parse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,
 	}
 #endif
       break;
-
     case OP_OPEN_SUBEXP:
       tree = parse_sub_exp (regexp, preg, token, syntax, nest + 1, err);
       if (BE (*err != REG_NOERROR && tree == NULL, 0))
 	return NULL;
       break;
-
     case OP_OPEN_BRACKET:
       tree = parse_bracket_exp (regexp, dfa, token, syntax, err);
       if (BE (*err != REG_NOERROR && tree == NULL, 0))
 	return NULL;
       break;
-
     case OP_BACK_REF:
       if (!BE (dfa->completed_bkref_map & (1 << token->opr.idx), 1))
 	{
@@ -2320,14 +2279,13 @@ parse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,
       ++dfa->nbackref;
       dfa->has_mb_node = 1;
       break;
-
     case OP_OPEN_DUP_NUM:
       if (syntax & RE_CONTEXT_INVALID_DUP)
 	{
 	  *err = REG_BADRPT;
 	  return NULL;
 	}
-      FALLTHROUGH;
+      /* FALLTHROUGH */
     case OP_DUP_ASTERISK:
     case OP_DUP_PLUS:
     case OP_DUP_QUESTION:
@@ -2341,7 +2299,7 @@ parse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,
 	  fetch_token (token, regexp, syntax);
 	  return parse_expression (regexp, preg, token, syntax, nest, err);
 	}
-      FALLTHROUGH;
+      /* else fall through  */
     case OP_CLOSE_SUBEXP:
       if ((token->type == OP_CLOSE_SUBEXP) &&
 	  !(syntax & RE_UNMATCHED_RIGHT_PAREN_ORD))
@@ -2349,7 +2307,7 @@ parse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,
 	  *err = REG_ERPAREN;
 	  return NULL;
 	}
-      FALLTHROUGH;
+      /* else fall through  */
     case OP_CLOSE_DUP_NUM:
       /* We treat it as a normal character.  */
 
@@ -2364,7 +2322,6 @@ parse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,
 	  return NULL;
 	}
       break;
-
     case ANCHOR:
       if ((token->opr.ctx_type
 	   & (WORD_DELIM | NOT_WORD_DELIM | WORD_FIRST | WORD_LAST))
@@ -2409,7 +2366,6 @@ parse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,
 	     it must not be "<ANCHOR(^)><REPEAT(*)>".  */
       fetch_token (token, regexp, syntax);
       return tree;
-
     case OP_PERIOD:
       tree = create_token_tree (dfa, NULL, NULL, token);
       if (BE (tree == NULL, 0))
@@ -2420,35 +2376,30 @@ parse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,
       if (dfa->mb_cur_max > 1)
 	dfa->has_mb_node = 1;
       break;
-
     case OP_WORD:
     case OP_NOTWORD:
       tree = build_charclass_op (dfa, regexp->trans,
-				 "alnum",
-				 "_",
+				 (const unsigned char *) "alnum",
+				 (const unsigned char *) "_",
 				 token->type == OP_NOTWORD, err);
       if (BE (*err != REG_NOERROR && tree == NULL, 0))
 	return NULL;
       break;
-
     case OP_SPACE:
     case OP_NOTSPACE:
       tree = build_charclass_op (dfa, regexp->trans,
-				 "space",
-				 "",
+				 (const unsigned char *) "space",
+				 (const unsigned char *) "",
 				 token->type == OP_NOTSPACE, err);
       if (BE (*err != REG_NOERROR && tree == NULL, 0))
 	return NULL;
       break;
-
     case OP_ALT:
     case END_OF_RE:
       return NULL;
-
     case BACK_SLASH:
       *err = REG_EESCAPE;
       return NULL;
-
     default:
       /* Must not happen?  */
 #ifdef DEBUG
@@ -2461,8 +2412,7 @@ parse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,
   while (token->type == OP_DUP_ASTERISK || token->type == OP_DUP_PLUS
 	 || token->type == OP_DUP_QUESTION || token->type == OP_OPEN_DUP_NUM)
     {
-      bin_tree_t *dup_tree = parse_dup_op (tree, regexp, dfa, token,
-					   syntax, err);
+      bin_tree_t *dup_tree = parse_dup_op (tree, regexp, dfa, token, syntax, err);
       if (BE (*err != REG_NOERROR && dup_tree == NULL, 0))
 	{
 	  if (tree != NULL)
@@ -2494,9 +2444,9 @@ parse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,
 
 static bin_tree_t *
 parse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,
-	       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)
+	       reg_syntax_t syntax, int nest, reg_errcode_t *err)
 {
-  re_dfa_t *dfa = preg->buffer;
+  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
   bin_tree_t *tree;
   size_t cur_nsub;
   cur_nsub = preg->re_nsub++;
@@ -2539,7 +2489,7 @@ parse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,
 	      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)
 {
   bin_tree_t *tree = NULL, *old_tree = NULL;
-  Idx i, start, end, start_idx = re_string_cur_idx (regexp);
+  int i, start, end, start_idx = re_string_cur_idx (regexp);
   re_token_t start_token = *token;
 
   if (token->type == OP_OPEN_DUP_NUM)
@@ -2585,19 +2535,12 @@ parse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,
 	  return elem;
 	}
 
-      if (BE ((end != -1 && start > end)
-	      || token->type != OP_CLOSE_DUP_NUM, 0))
+      if (BE ((end != -1 && start > end) || token->type != OP_CLOSE_DUP_NUM, 0))
 	{
 	  /* First number greater than second.  */
 	  *err = REG_BADBR;
 	  return NULL;
 	}
-
-      if (BE (RE_DUP_MAX < (end == -1 ? start : end), 0))
-	{
-	  *err = REG_ESIZE;
-	  return NULL;
-	}
     }
   else
     {
@@ -2640,31 +2583,26 @@ parse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,
     old_tree = NULL;
 
   if (elem->token.type == SUBEXP)
-    {
-      uintptr_t subidx = elem->token.opr.idx;
-      postorder (elem, mark_opt_subexp, (void *) subidx);
-    }
+    postorder (elem, mark_opt_subexp, (void *) (long) elem->token.opr.idx);
 
-  tree = create_tree (dfa, elem, NULL,
-		      (end == -1 ? OP_DUP_ASTERISK : OP_ALT));
+  tree = create_tree (dfa, elem, NULL, (end == -1 ? OP_DUP_ASTERISK : OP_ALT));
   if (BE (tree == NULL, 0))
     goto parse_dup_op_espace;
 
   /* This loop is actually executed only when end != -1,
      to rewrite <re>{0,n} as (<re>(<re>...<re>?)?)?...  We have
      already created the start+1-th copy.  */
-  if (TYPE_SIGNED (Idx) || end != -1)
-    for (i = start + 2; i <= end; ++i)
-      {
-	elem = duplicate_tree (elem, dfa);
-	tree = create_tree (dfa, tree, elem, CONCAT);
-	if (BE (elem == NULL || tree == NULL, 0))
-	  goto parse_dup_op_espace;
+  for (i = start + 2; i <= end; ++i)
+    {
+      elem = duplicate_tree (elem, dfa);
+      tree = create_tree (dfa, tree, elem, CONCAT);
+      if (BE (elem == NULL || tree == NULL, 0))
+	goto parse_dup_op_espace;
 
-	tree = create_tree (dfa, tree, NULL, OP_ALT);
-	if (BE (tree == NULL, 0))
-	  goto parse_dup_op_espace;
-      }
+      tree = create_tree (dfa, tree, NULL, OP_ALT);
+      if (BE (tree == NULL, 0))
+	goto parse_dup_op_espace;
+    }
 
   if (old_tree)
     tree = create_tree (dfa, old_tree, tree, CONCAT);
@@ -2681,19 +2619,6 @@ parse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,
 #define BRACKET_NAME_BUF_SIZE 32
 
 #ifndef _LIBC
-
-# ifdef RE_ENABLE_I18N
-/* Convert the byte B to the corresponding wide character.  In a
-   unibyte locale, treat B as itself if it is an encoding error.
-   In a multibyte locale, return WEOF if B is an encoding error.  */
-static wint_t
-parse_byte (unsigned char b, re_charset_t *mbcset)
-{
-  wint_t wc = __btowc (b);
-  return wc == WEOF && !mbcset ? b : wc;
-}
-#endif
-
   /* Local function for parse_bracket_exp only used in case of NOT _LIBC.
      Build the range expression which starts from START_ELEM, and ends
      at END_ELEM.  The result are written to MBCSET and SBCSET.
@@ -2703,17 +2628,11 @@ parse_byte (unsigned char b, re_charset_t *mbcset)
 
 static reg_errcode_t
 # ifdef RE_ENABLE_I18N
-build_range_exp (const reg_syntax_t syntax,
-                 bitset_t sbcset,
-                 re_charset_t *mbcset,
-                 Idx *range_alloc,
-                 const bracket_elem_t *start_elem,
-                 const bracket_elem_t *end_elem)
+build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,
+		 bracket_elem_t *start_elem, bracket_elem_t *end_elem)
 # else /* not RE_ENABLE_I18N */
-build_range_exp (const reg_syntax_t syntax,
-                 bitset_t sbcset,
-                 const bracket_elem_t *start_elem,
-                 const bracket_elem_t *end_elem)
+build_range_exp (bitset_t sbcset, bracket_elem_t *start_elem,
+		 bracket_elem_t *end_elem)
 # endif /* not RE_ENABLE_I18N */
 {
   unsigned int start_ch, end_ch;
@@ -2736,6 +2655,7 @@ build_range_exp (const reg_syntax_t syntax,
     wchar_t wc;
     wint_t start_wc;
     wint_t end_wc;
+    wchar_t cmp_buf[6] = {L'\0', L'\0', L'\0', L'\0', L'\0', L'\0'};
 
     start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch
 		: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]
@@ -2744,12 +2664,14 @@ build_range_exp (const reg_syntax_t syntax,
 	      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]
 		 : 0));
     start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)
-		? parse_byte (start_ch, mbcset) : start_elem->opr.wch);
+		? __btowc (start_ch) : start_elem->opr.wch);
     end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)
-	      ? parse_byte (end_ch, mbcset) : end_elem->opr.wch);
+	      ? __btowc (end_ch) : end_elem->opr.wch);
     if (start_wc == WEOF || end_wc == WEOF)
       return REG_ECOLLATE;
-    else if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_wc > end_wc, 0))
+    cmp_buf[0] = start_wc;
+    cmp_buf[4] = end_wc;
+    if (__wcscoll (cmp_buf, cmp_buf + 4) > 0)
       return REG_ERANGE;
 
     /* Got valid collation sequence values, add them as a new entry.
@@ -2764,7 +2686,7 @@ build_range_exp (const reg_syntax_t syntax,
 	  {
 	    /* There is not enough space, need realloc.  */
 	    wchar_t *new_array_start, *new_array_end;
-	    Idx new_nranges;
+	    int new_nranges;
 
 	    /* +1 in case of mbcset->nranges is 0.  */
 	    new_nranges = 2 * mbcset->nranges + 1;
@@ -2776,11 +2698,7 @@ build_range_exp (const reg_syntax_t syntax,
 					new_nranges);
 
 	    if (BE (new_array_start == NULL || new_array_end == NULL, 0))
-	      {
-		re_free (new_array_start);
-		re_free (new_array_end);
-		return REG_ESPACE;
-	      }
+	      return REG_ESPACE;
 
 	    mbcset->range_starts = new_array_start;
 	    mbcset->range_ends = new_array_end;
@@ -2794,7 +2712,9 @@ build_range_exp (const reg_syntax_t syntax,
     /* Build the table for single byte characters.  */
     for (wc = 0; wc < SBC_MAX; ++wc)
       {
-	if (start_wc <= wc && wc <= end_wc)
+	cmp_buf[2] = wc;
+	if (__wcscoll (cmp_buf, cmp_buf + 2) <= 0
+	    && __wcscoll (cmp_buf + 2, cmp_buf + 4) <= 0)
 	  bitset_set (sbcset, wc);
       }
   }
@@ -2829,7 +2749,7 @@ build_range_exp (const reg_syntax_t syntax,
 static reg_errcode_t
 # ifdef RE_ENABLE_I18N
 build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,
-			Idx *coll_sym_alloc, const unsigned char *name)
+			int *coll_sym_alloc, const unsigned char *name)
 # else /* not RE_ENABLE_I18N */
 build_collating_symbol (bitset_t sbcset, const unsigned char *name)
 # endif /* not RE_ENABLE_I18N */
@@ -2975,7 +2895,6 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
 	      0))
 	return REG_ERANGE;
 
-      /* FIXME: Implement rational ranges here, too.  */
       start_collseq = lookup_collation_sequence_value (start_elem);
       end_collseq = lookup_collation_sequence_value (end_elem);
       /* Check start/end collation sequence values.  */
@@ -2996,7 +2915,7 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
 	      /* There is not enough space, need realloc.  */
 	      uint32_t *new_array_start;
 	      uint32_t *new_array_end;
-	      Idx new_nranges;
+	      int new_nranges;
 
 	      /* +1 in case of mbcset->nranges is 0.  */
 	      new_nranges = 2 * mbcset->nranges + 1;
@@ -3043,7 +2962,7 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
   auto inline reg_errcode_t
   __attribute__ ((always_inline))
   build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,
-			  Idx *coll_sym_alloc, const unsigned char *name)
+			  int *coll_sym_alloc, const unsigned char *name)
     {
       int32_t elem, idx;
       size_t name_len = strlen ((const char *) name);
@@ -3073,7 +2992,7 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
 	    {
 	      /* Not enough, realloc it.  */
 	      /* +1 in case of mbcset->ncoll_syms is 0.  */
-	      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;
+	      int new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;
 	      /* Use realloc since mbcset->coll_syms is NULL
 		 if *alloc == 0.  */
 	      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,
@@ -3103,13 +3022,13 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
   re_bitset_ptr_t sbcset;
 #ifdef RE_ENABLE_I18N
   re_charset_t *mbcset;
-  Idx coll_sym_alloc = 0, range_alloc = 0, mbchar_alloc = 0;
-  Idx equiv_class_alloc = 0, char_class_alloc = 0;
+  int coll_sym_alloc = 0, range_alloc = 0, mbchar_alloc = 0;
+  int equiv_class_alloc = 0, char_class_alloc = 0;
 #endif /* not RE_ENABLE_I18N */
-  bool non_match = false;
+  int non_match = 0;
   bin_tree_t *work_tree;
   int token_len;
-  bool first_round = true;
+  int first_round = 1;
 #ifdef _LIBC
   collseqmb = (const unsigned char *)
     _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);
@@ -3156,7 +3075,7 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
 #ifdef RE_ENABLE_I18N
       mbcset->non_match = 1;
 #endif /* not RE_ENABLE_I18N */
-      non_match = true;
+      non_match = 1;
       if (syntax & RE_HAT_LISTS_NOT_NEWLINE)
 	bitset_set (sbcset, '\n');
       re_string_skip_bytes (regexp, token_len); /* Skip a token.  */
@@ -3178,8 +3097,7 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
       unsigned char start_name_buf[BRACKET_NAME_BUF_SIZE];
       unsigned char end_name_buf[BRACKET_NAME_BUF_SIZE];
       reg_errcode_t ret;
-      int token_len2 = 0;
-      bool is_range_exp = false;
+      int token_len2 = 0, is_range_exp = 0;
       re_token_t token2;
 
       start_elem.opr.name = start_name_buf;
@@ -3191,7 +3109,7 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
 	  *err = ret;
 	  goto parse_bracket_exp_free_return;
 	}
-      first_round = false;
+      first_round = 0;
 
       /* Get information about the next token.  We need it in any case.  */
       token_len = peek_token_bracket (token, regexp, syntax);
@@ -3220,16 +3138,16 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
 		  token->type = CHARACTER;
 		}
 	      else
-		is_range_exp = true;
+		is_range_exp = 1;
 	    }
 	}
 
-      if (is_range_exp == true)
+      if (is_range_exp == 1)
 	{
 	  end_elem.opr.name = end_name_buf;
 	  end_elem.type = COLL_SYM;
 	  ret = parse_bracket_element (&end_elem, regexp, &token2, token_len2,
-				       dfa, syntax, true);
+				       dfa, syntax, 1);
 	  if (BE (ret != REG_NOERROR, 0))
 	    {
 	      *err = ret;
@@ -3243,11 +3161,11 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
 				  &start_elem, &end_elem);
 #else
 # ifdef RE_ENABLE_I18N
-	  *err = build_range_exp (syntax, sbcset,
+	  *err = build_range_exp (sbcset,
 				  dfa->mb_cur_max > 1 ? mbcset : NULL,
 				  &range_alloc, &start_elem, &end_elem);
 # else
-	  *err = build_range_exp (syntax, sbcset, &start_elem, &end_elem);
+	  *err = build_range_exp (sbcset, &start_elem, &end_elem);
 # endif
 #endif /* RE_ENABLE_I18N */
 	  if (BE (*err != REG_NOERROR, 0))
@@ -3302,8 +3220,7 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
 #ifdef RE_ENABLE_I18N
 				      mbcset, &char_class_alloc,
 #endif /* RE_ENABLE_I18N */
-				      (const char *) start_elem.opr.name,
-				      syntax);
+				      start_elem.opr.name, syntax);
 	      if (BE (*err != REG_NOERROR, 0))
 	       goto parse_bracket_exp_free_return;
 	      break;
@@ -3400,7 +3317,7 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
 static reg_errcode_t
 parse_bracket_element (bracket_elem_t *elem, re_string_t *regexp,
 		       re_token_t *token, int token_len, re_dfa_t *dfa,
-		       reg_syntax_t syntax, bool accept_hyphen)
+		       reg_syntax_t syntax, int accept_hyphen)
 {
 #ifdef RE_ENABLE_I18N
   int cur_char_size;
@@ -3487,7 +3404,7 @@ parse_bracket_symbol (bracket_elem_t *elem, re_string_t *regexp,
 static reg_errcode_t
 #ifdef RE_ENABLE_I18N
 build_equiv_class (bitset_t sbcset, re_charset_t *mbcset,
-		   Idx *equiv_class_alloc, const unsigned char *name)
+		   int *equiv_class_alloc, const unsigned char *name)
 #else /* not RE_ENABLE_I18N */
 build_equiv_class (bitset_t sbcset, const unsigned char *name)
 #endif /* not RE_ENABLE_I18N */
@@ -3549,7 +3466,7 @@ build_equiv_class (bitset_t sbcset, const unsigned char *name)
 	{
 	  /* Not enough, realloc it.  */
 	  /* +1 in case of mbcset->nequiv_classes is 0.  */
-	  Idx new_equiv_class_alloc = 2 * mbcset->nequiv_classes + 1;
+	  int new_equiv_class_alloc = 2 * mbcset->nequiv_classes + 1;
 	  /* Use realloc since the array is NULL if *alloc == 0.  */
 	  int32_t *new_equiv_classes = re_realloc (mbcset->equiv_classes,
 						   int32_t,
@@ -3580,15 +3497,15 @@ build_equiv_class (bitset_t sbcset, const unsigned char *name)
 static reg_errcode_t
 #ifdef RE_ENABLE_I18N
 build_charclass (RE_TRANSLATE_TYPE trans, bitset_t sbcset,
-		 re_charset_t *mbcset, Idx *char_class_alloc,
-		 const char *class_name, reg_syntax_t syntax)
+		 re_charset_t *mbcset, int *char_class_alloc,
+		 const unsigned char *class_name, reg_syntax_t syntax)
 #else /* not RE_ENABLE_I18N */
 build_charclass (RE_TRANSLATE_TYPE trans, bitset_t sbcset,
-		 const char *class_name, reg_syntax_t syntax)
+		 const unsigned char *class_name, reg_syntax_t syntax)
 #endif /* not RE_ENABLE_I18N */
 {
   int i;
-  const char *name = class_name;
+  const char *name = (const char *) class_name;
 
   /* In case of REG_ICASE "upper" and "lower" match the both of
      upper and lower cases.  */
@@ -3602,7 +3519,7 @@ build_charclass (RE_TRANSLATE_TYPE trans, bitset_t sbcset,
     {
       /* Not enough, realloc it.  */
       /* +1 in case of mbcset->nchar_classes is 0.  */
-      Idx new_char_class_alloc = 2 * mbcset->nchar_classes + 1;
+      int new_char_class_alloc = 2 * mbcset->nchar_classes + 1;
       /* Use realloc since array is NULL if *alloc == 0.  */
       wctype_t *new_char_classes = re_realloc (mbcset->char_classes, wctype_t,
 					       new_char_class_alloc);
@@ -3619,13 +3536,13 @@ build_charclass (RE_TRANSLATE_TYPE trans, bitset_t sbcset,
     if (BE (trans != NULL, 0))			\
       {						\
 	for (i = 0; i < SBC_MAX; ++i)		\
-	  if (ctype_func (i))			\
+  	  if (ctype_func (i))			\
 	    bitset_set (sbcset, trans[i]);	\
       }						\
     else					\
       {						\
 	for (i = 0; i < SBC_MAX; ++i)		\
-	  if (ctype_func (i))			\
+  	  if (ctype_func (i))			\
 	    bitset_set (sbcset, i);		\
       }						\
   } while (0)
@@ -3662,36 +3579,41 @@ build_charclass (RE_TRANSLATE_TYPE trans, bitset_t sbcset,
 
 static bin_tree_t *
 build_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,
-		    const char *class_name,
-		    const char *extra, bool non_match,
+		    const unsigned char *class_name,
+		    const unsigned char *extra, int non_match,
 		    reg_errcode_t *err)
 {
   re_bitset_ptr_t sbcset;
 #ifdef RE_ENABLE_I18N
   re_charset_t *mbcset;
-  Idx alloc = 0;
+  int alloc = 0;
 #endif /* not RE_ENABLE_I18N */
   reg_errcode_t ret;
   re_token_t br_token;
   bin_tree_t *tree;
 
   sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);
-  if (BE (sbcset == NULL, 0))
-    {
-      *err = REG_ESPACE;
-      return NULL;
-    }
 #ifdef RE_ENABLE_I18N
   mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);
-  if (BE (mbcset == NULL, 0))
-    {
-      re_free (sbcset);
-      *err = REG_ESPACE;
-      return NULL;
-    }
-  mbcset->non_match = non_match;
 #endif /* RE_ENABLE_I18N */
 
+#ifdef RE_ENABLE_I18N
+  if (BE (sbcset == NULL || mbcset == NULL, 0))
+#else /* not RE_ENABLE_I18N */
+  if (BE (sbcset == NULL, 0))
+#endif /* not RE_ENABLE_I18N */
+    {
+      *err = REG_ESPACE;
+      return NULL;
+    }
+
+  if (non_match)
+    {
+#ifdef RE_ENABLE_I18N
+      mbcset->non_match = 1;
+#endif /* not RE_ENABLE_I18N */
+    }
+
   /* We don't care the syntax in this case.  */
   ret = build_charclass (trans, sbcset,
 #ifdef RE_ENABLE_I18N
@@ -3723,9 +3645,6 @@ build_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,
 #endif
 
   /* Build a tree for simple bracket.  */
-#if defined GCC_LINT || defined lint
-  memset (&br_token, 0, sizeof br_token);
-#endif
   br_token.type = SIMPLE_BRACKET;
   br_token.opr.sbcset = sbcset;
   tree = create_token_tree (dfa, NULL, NULL, &br_token);
@@ -3767,15 +3686,14 @@ build_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,
 }
 
 /* This is intended for the expressions like "a{1,3}".
-   Fetch a number from 'input', and return the number.
-   Return -1 if the number field is empty like "{,1}".
-   Return RE_DUP_MAX + 1 if the number field is too large.
-   Return -2 if an error occurred.  */
+   Fetch a number from `input', and return the number.
+   Return -1, if the number field is empty like "{,1}".
+   Return -2, If an error is occured.  */
 
-static Idx
+static int
 fetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)
 {
-  Idx num = -1;
+  int num = -1;
   unsigned char c;
   while (1)
     {
@@ -3786,10 +3704,8 @@ fetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)
       if (token->type == OP_CLOSE_DUP_NUM || c == ',')
 	break;
       num = ((token->type != CHARACTER || c < '0' || '9' < c || num == -2)
-	     ? -2
-	     : num == -1
-	     ? c - '0'
-	     : MIN (RE_DUP_MAX + 1, num * 10 + c - '0'));
+	     ? -2 : ((num == -1) ? c - '0' : num * 10 + c - '0'));
+      num = (num > RE_DUP_MAX) ? -2 : num;
     }
   return num;
 }
@@ -3819,9 +3735,6 @@ create_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,
 	     re_token_type_t type)
 {
   re_token_t t;
-#if defined GCC_LINT || defined lint
-  memset (&t, 0, sizeof t);
-#endif
   t.type = type;
   return create_token_tree (dfa, left, right, &t);
 }
@@ -3866,7 +3779,7 @@ create_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,
 static reg_errcode_t
 mark_opt_subexp (void *extra, bin_tree_t *node)
 {
-  Idx idx = (uintptr_t) extra;
+  int idx = (int) (long) extra;
   if (node->token.type == SUBEXP && node->token.opr.idx == idx)
     node->token.opt_subexp = 1;
 
diff --git a/posix/regex.c b/posix/regex.c
index d6591e8670..68b5ef17ba 100644
--- a/posix/regex.c
+++ b/posix/regex.c
@@ -15,22 +15,14 @@
 
    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
+   <http://www.gnu.org/licenses/>.  */
 
-#ifndef _LIBC
-# include <config.h>
-
-# if (__GNUC__ == 4 && 6 <= __GNUC_MINOR__) || 4 < __GNUC__
-#  pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
-# endif
-# if (__GNUC__ == 4 && 3 <= __GNUC_MINOR__) || 4 < __GNUC__
-#  pragma GCC diagnostic ignored "-Wold-style-definition"
-#  pragma GCC diagnostic ignored "-Wtype-limits"
-# endif
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-/* Make sure no one compiles this code with a C++ compiler.  */
-#if defined __cplusplus && defined _LIBC
+/* Make sure noone compiles this code with a C++ compiler.  */
+#ifdef __cplusplus
 # error "This is C code, use a C compiler"
 #endif
 
@@ -64,6 +56,9 @@
    #undefs RE_DUP_MAX and sets it to the right value.  */
 #include <limits.h>
 
+/* This header defines the MIN and MAX macros.  */
+#include <sys/param.h>
+
 #include <regex.h>
 #include "regex_internal.h"
 
diff --git a/posix/regex.h b/posix/regex.h
index 32933bc6d5..e0b89158a8 100644
--- a/posix/regex.h
+++ b/posix/regex.h
@@ -15,7 +15,7 @@
 
    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
+   <http://www.gnu.org/licenses/>.  */
 
 #ifndef _REGEX_H
 #define _REGEX_H 1
@@ -27,36 +27,6 @@
 extern "C" {
 #endif
 
-/* Define __USE_GNU to declare GNU extensions that violate the
-   POSIX name space rules.  */
-#ifdef _GNU_SOURCE
-# define __USE_GNU 1
-#endif
-
-#ifdef _REGEX_LARGE_OFFSETS
-
-/* Use types and values that are wide enough to represent signed and
-   unsigned byte offsets in memory.  This currently works only when
-   the regex code is used outside of the GNU C library; it is not yet
-   supported within glibc itself, and glibc users should not define
-   _REGEX_LARGE_OFFSETS.  */
-
-/* The type of object sizes.  */
-typedef size_t __re_size_t;
-
-/* The type of object sizes, in places where the traditional code
-   uses unsigned long int.  */
-typedef size_t __re_long_size_t;
-
-#else
-
-/* The traditional GNU regex implementation mishandles strings longer
-   than INT_MAX.  */
-typedef unsigned int __re_size_t;
-typedef unsigned long int __re_long_size_t;
-
-#endif
-
 /* The following two types have to be signed and unsigned integer type
    wide enough to hold a value of a pointer.  For most ANSI compilers
    ptrdiff_t and size_t should be likely OK.  Still size of these two
@@ -138,9 +108,9 @@ typedef unsigned long int reg_syntax_t;
    If not set, newline is literal.  */
 # define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
 
-/* If this bit is set, then '{...}' defines an interval, and \{ and \}
+/* If this bit is set, then `{...}' defines an interval, and \{ and \}
      are literals.
-  If not set, then '\{...\}' defines an interval.  */
+  If not set, then `\{...\}' defines an interval.  */
 # define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
 
 /* If this bit is set, (...) defines a group, and \( and \) are literals.
@@ -195,8 +165,8 @@ typedef unsigned long int reg_syntax_t;
    whether ^ should be special.  */
 # define RE_CARET_ANCHORS_HERE (RE_ICASE << 1)
 
-/* If this bit is set, then \{ cannot be first in a regex or
-   immediately after an alternation, open-group or \} operator.  */
+/* If this bit is set, then \{ cannot be first in an bre or
+   immediately after an alternation or begin-group operator.  */
 # define RE_CONTEXT_INVALID_DUP (RE_CARET_ANCHORS_HERE << 1)
 
 /* If this bit is set, then no_sub will be set to 1 during
@@ -215,9 +185,9 @@ extern reg_syntax_t re_syntax_options;
    (The [[[ comments delimit what gets put into the Texinfo file, so
    don't delete them!)  */
 /* [[[begin syntaxes]]] */
-# define RE_SYNTAX_EMACS 0
+#define RE_SYNTAX_EMACS 0
 
-# define RE_SYNTAX_AWK							\
+#define RE_SYNTAX_AWK							\
   (RE_BACKSLASH_ESCAPE_IN_LISTS   | RE_DOT_NOT_NULL			\
    | RE_NO_BK_PARENS              | RE_NO_BK_REFS			\
    | RE_NO_BK_VBAR                | RE_NO_EMPTY_RANGES			\
@@ -225,49 +195,52 @@ extern reg_syntax_t re_syntax_options;
    | RE_CHAR_CLASSES							\
    | RE_UNMATCHED_RIGHT_PAREN_ORD | RE_NO_GNU_OPS)
 
-# define RE_SYNTAX_GNU_AWK						\
+#define RE_SYNTAX_GNU_AWK						\
   ((RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS		\
     | RE_INVALID_INTERVAL_ORD)						\
    & ~(RE_DOT_NOT_NULL | RE_CONTEXT_INDEP_OPS				\
       | RE_CONTEXT_INVALID_OPS ))
 
-# define RE_SYNTAX_POSIX_AWK						\
+#define RE_SYNTAX_POSIX_AWK						\
   (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS		\
    | RE_INTERVALS	    | RE_NO_GNU_OPS				\
    | RE_INVALID_INTERVAL_ORD)
 
-# define RE_SYNTAX_GREP							\
-  ((RE_SYNTAX_POSIX_BASIC | RE_NEWLINE_ALT)				\
-   & ~(RE_CONTEXT_INVALID_DUP | RE_DOT_NOT_NULL))
+#define RE_SYNTAX_GREP							\
+  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES				\
+   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS				\
+   | RE_NEWLINE_ALT)
 
-# define RE_SYNTAX_EGREP						\
-  ((RE_SYNTAX_POSIX_EXTENDED | RE_INVALID_INTERVAL_ORD | RE_NEWLINE_ALT) \
-   & ~(RE_CONTEXT_INVALID_OPS | RE_DOT_NOT_NULL))
+#define RE_SYNTAX_EGREP							\
+  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE			\
+   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS				\
+   | RE_NO_BK_VBAR)
 
-/* POSIX grep -E behavior is no longer incompatible with GNU.  */
-# define RE_SYNTAX_POSIX_EGREP						\
-  RE_SYNTAX_EGREP
+#define RE_SYNTAX_POSIX_EGREP						\
+  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES			\
+   | RE_INVALID_INTERVAL_ORD)
 
 /* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
-# define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
+#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
 
-# define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
+#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
 
 /* Syntax bits common to both basic and extended POSIX regex syntax.  */
-# define _RE_SYNTAX_POSIX_COMMON					\
+#define _RE_SYNTAX_POSIX_COMMON						\
   (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL		\
    | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
 
-# define RE_SYNTAX_POSIX_BASIC						\
+#define RE_SYNTAX_POSIX_BASIC						\
   (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM | RE_CONTEXT_INVALID_DUP)
 
 /* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
    RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
    isn't minimal, since other operators, such as \`, aren't disabled.  */
-# define RE_SYNTAX_POSIX_MINIMAL_BASIC					\
+#define RE_SYNTAX_POSIX_MINIMAL_BASIC					\
   (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
 
-# define RE_SYNTAX_POSIX_EXTENDED					\
+#define RE_SYNTAX_POSIX_EXTENDED					\
   (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
    | RE_CONTEXT_INDEP_OPS   | RE_NO_BK_BRACES				\
    | RE_NO_BK_PARENS        | RE_NO_BK_VBAR				\
@@ -275,35 +248,25 @@ extern reg_syntax_t re_syntax_options;
 
 /* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INDEP_OPS is
    removed and RE_NO_BK_REFS is added.  */
-# define RE_SYNTAX_POSIX_MINIMAL_EXTENDED				\
+#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED				\
   (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
    | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES				\
    | RE_NO_BK_PARENS        | RE_NO_BK_REFS				\
    | RE_NO_BK_VBAR	    | RE_UNMATCHED_RIGHT_PAREN_ORD)
 /* [[[end syntaxes]]] */
-
-/* Maximum number of duplicates an interval can allow.  POSIX-conforming
-   systems might define this in <limits.h>, but we want our
+
+/* Maximum number of duplicates an interval can allow.  Some systems
+   (erroneously) define this in other header files, but we want our
    value, so remove any previous define.  */
-# ifdef _REGEX_INCLUDE_LIMITS_H
-#  include <limits.h>
-# endif
 # ifdef RE_DUP_MAX
 #  undef RE_DUP_MAX
 # endif
-
-/* RE_DUP_MAX is 2**15 - 1 because an earlier implementation stored
-   the counter as a 2-byte signed integer.  This is no longer true, so
-   RE_DUP_MAX could be increased to (INT_MAX / 10 - 1), or to
-   ((SIZE_MAX - 9) / 10) if _REGEX_LARGE_OFFSETS is defined.
-   However, there would be a huge performance problem if someone
-   actually used a pattern like a\{214748363\}, so RE_DUP_MAX retains
-   its historical value.  */
+/* If sizeof(int) == 2, then ((1 << 15) - 1) overflows.  */
 # define RE_DUP_MAX (0x7fff)
 #endif
 
 
-/* POSIX 'cflags' bits (i.e., information for 'regcomp').  */
+/* POSIX `cflags' bits (i.e., information for `regcomp').  */
 
 /* If this bit is set, then use extended regular expression syntax.
    If not set, then use basic regular expression syntax.  */
@@ -311,19 +274,19 @@ extern reg_syntax_t re_syntax_options;
 
 /* If this bit is set, then ignore case when matching.
    If not set, then case is significant.  */
-#define REG_ICASE (1 << 1)
+#define REG_ICASE (REG_EXTENDED << 1)
 
 /* If this bit is set, then anchors do not match at newline
      characters in the string.
    If not set, then anchors do match at newlines.  */
-#define REG_NEWLINE (1 << 2)
+#define REG_NEWLINE (REG_ICASE << 1)
 
 /* If this bit is set, then report only success or fail in regexec.
    If not set, then returns differ between not matching and errors.  */
-#define REG_NOSUB (1 << 3)
+#define REG_NOSUB (REG_NEWLINE << 1)
 
 
-/* POSIX 'eflags' bits (i.e., information for regexec).  */
+/* POSIX `eflags' bits (i.e., information for regexec).  */
 
 /* If this bit is set, then the beginning-of-line operator doesn't match
      the beginning of the string (presumably because it's not the
@@ -341,60 +304,41 @@ extern reg_syntax_t re_syntax_options;
 
 
 /* If any error codes are removed, changed, or added, update the
-   '__re_error_msgid' table in regcomp.c.  */
-
+   `re_error_msg' table in regex.c.  */
 typedef enum
 {
-  _REG_ENOSYS = -1,	/* This will never happen for this implementation.  */
-  _REG_NOERROR = 0,	/* Success.  */
-  _REG_NOMATCH,		/* Didn't find a match (for regexec).  */
+#if defined _XOPEN_SOURCE || defined __USE_XOPEN2K
+  REG_ENOSYS = -1,	/* This will never happen for this implementation.  */
+#endif
+
+  REG_NOERROR = 0,	/* Success.  */
+  REG_NOMATCH,		/* Didn't find a match (for regexec).  */
 
   /* POSIX regcomp return error codes.  (In the order listed in the
      standard.)  */
-  _REG_BADPAT,		/* Invalid pattern.  */
-  _REG_ECOLLATE,	/* Invalid collating element.  */
-  _REG_ECTYPE,		/* Invalid character class name.  */
-  _REG_EESCAPE,		/* Trailing backslash.  */
-  _REG_ESUBREG,		/* Invalid back reference.  */
-  _REG_EBRACK,		/* Unmatched left bracket.  */
-  _REG_EPAREN,		/* Parenthesis imbalance.  */
-  _REG_EBRACE,		/* Unmatched \{.  */
-  _REG_BADBR,		/* Invalid contents of \{\}.  */
-  _REG_ERANGE,		/* Invalid range end.  */
-  _REG_ESPACE,		/* Ran out of memory.  */
-  _REG_BADRPT,		/* No preceding re for repetition op.  */
+  REG_BADPAT,		/* Invalid pattern.  */
+  REG_ECOLLATE,		/* Invalid collating element.  */
+  REG_ECTYPE,		/* Invalid character class name.  */
+  REG_EESCAPE,		/* Trailing backslash.  */
+  REG_ESUBREG,		/* Invalid back reference.  */
+  REG_EBRACK,		/* Unmatched left bracket.  */
+  REG_EPAREN,		/* Parenthesis imbalance.  */
+  REG_EBRACE,		/* Unmatched \{.  */
+  REG_BADBR,		/* Invalid contents of \{\}.  */
+  REG_ERANGE,		/* Invalid range end.  */
+  REG_ESPACE,		/* Ran out of memory.  */
+  REG_BADRPT,		/* No preceding re for repetition op.  */
 
   /* Error codes we've added.  */
-  _REG_EEND,		/* Premature end.  */
-  _REG_ESIZE,		/* Too large (e.g., repeat count too large).  */
-  _REG_ERPAREN		/* Unmatched ) or \); not returned from regcomp.  */
+  REG_EEND,		/* Premature end.  */
+  REG_ESIZE,		/* Compiled pattern bigger than 2^16 bytes.  */
+  REG_ERPAREN		/* Unmatched ) or \); not returned from regcomp.  */
 } reg_errcode_t;
-
-#if defined _XOPEN_SOURCE || defined __USE_XOPEN2K
-# define REG_ENOSYS	_REG_ENOSYS
-#endif
-#define REG_NOERROR	_REG_NOERROR
-#define REG_NOMATCH	_REG_NOMATCH
-#define REG_BADPAT	_REG_BADPAT
-#define REG_ECOLLATE	_REG_ECOLLATE
-#define REG_ECTYPE	_REG_ECTYPE
-#define REG_EESCAPE	_REG_EESCAPE
-#define REG_ESUBREG	_REG_ESUBREG
-#define REG_EBRACK	_REG_EBRACK
-#define REG_EPAREN	_REG_EPAREN
-#define REG_EBRACE	_REG_EBRACE
-#define REG_BADBR	_REG_BADBR
-#define REG_ERANGE	_REG_ERANGE
-#define REG_ESPACE	_REG_ESPACE
-#define REG_BADRPT	_REG_BADRPT
-#define REG_EEND	_REG_EEND
-#define REG_ESIZE	_REG_ESIZE
-#define REG_ERPAREN	_REG_ERPAREN
 
 /* This data structure represents a compiled pattern.  Before calling
-   the pattern compiler, the fields 'buffer', 'allocated', 'fastmap',
-   and 'translate' can be set.  After the pattern has been compiled,
-   the fields 're_nsub', 'not_bol' and 'not_eol' are available.  All
+   the pattern compiler, the fields `buffer', `allocated', `fastmap',
+   and `translate' can be set.  After the pattern has been compiled,
+   the fields `re_nsub', `not_bol' and `not_eol' are available.  All
    other fields are private to the regex routines.  */
 
 #ifndef RE_TRANSLATE_TYPE
@@ -412,15 +356,16 @@ typedef enum
 
 struct re_pattern_buffer
 {
-  /* Space that holds the compiled pattern.  The type
-     'struct re_dfa_t' is private and is not declared here.  */
-  struct re_dfa_t *__REPB_PREFIX(buffer);
+  /* Space that holds the compiled pattern.  It is declared as
+     `unsigned char *' because its elements are sometimes used as
+     array indexes.  */
+  unsigned char *__REPB_PREFIX(buffer);
 
-  /* Number of bytes to which 'buffer' points.  */
-  __re_long_size_t __REPB_PREFIX(allocated);
+  /* Number of bytes to which `buffer' points.  */
+  unsigned long int __REPB_PREFIX(allocated);
 
-  /* Number of bytes actually used in 'buffer'.  */
-  __re_long_size_t __REPB_PREFIX(used);
+  /* Number of bytes actually used in `buffer'.  */
+  unsigned long int __REPB_PREFIX(used);
 
   /* Syntax setting with which the pattern was compiled.  */
   reg_syntax_t __REPB_PREFIX(syntax);
@@ -440,13 +385,13 @@ struct re_pattern_buffer
   size_t re_nsub;
 
   /* Zero if this pattern cannot match the empty string, one else.
-     Well, in truth it's used only in 're_search_2', to see whether or
+     Well, in truth it's used only in `re_search_2', to see whether or
      not we should use the fastmap, so we don't set this absolutely
-     perfectly; see 're_compile_fastmap' (the "duplicate" case).  */
+     perfectly; see `re_compile_fastmap' (the `duplicate' case).  */
   unsigned __REPB_PREFIX(can_be_null) : 1;
 
-  /* If REGS_UNALLOCATED, allocate space in the 'regs' structure
-     for 'max (RE_NREGS, re_nsub + 1)' groups.
+  /* If REGS_UNALLOCATED, allocate space in the `regs' structure
+     for `max (RE_NREGS, re_nsub + 1)' groups.
      If REGS_REALLOCATE, reallocate space if necessary.
      If REGS_FIXED, use what's there.  */
 #ifdef __USE_GNU
@@ -456,11 +401,11 @@ struct re_pattern_buffer
 #endif
   unsigned __REPB_PREFIX(regs_allocated) : 2;
 
-  /* Set to zero when 're_compile_pattern' compiles a pattern; set to
-     one by 're_compile_fastmap' if it updates the fastmap.  */
+  /* Set to zero when `regex_compile' compiles a pattern; set to one
+     by `re_compile_fastmap' if it updates the fastmap.  */
   unsigned __REPB_PREFIX(fastmap_accurate) : 1;
 
-  /* If set, 're_match_2' does not return information about
+  /* If set, `re_match_2' does not return information about
      subexpressions.  */
   unsigned __REPB_PREFIX(no_sub) : 1;
 
@@ -478,17 +423,7 @@ struct re_pattern_buffer
 typedef struct re_pattern_buffer regex_t;
 
 /* Type for byte offsets within the string.  POSIX mandates this.  */
-#ifdef _REGEX_LARGE_OFFSETS
-/* POSIX 1003.1-2008 requires that regoff_t be at least as wide as
-   ptrdiff_t and ssize_t.  We don't know of any hosts where ptrdiff_t
-   is wider than ssize_t, so ssize_t is safe.  ptrdiff_t is not
-   visible here, so use ssize_t.  */
-typedef ssize_t regoff_t;
-#else
-/* The traditional GNU regex implementation mishandles strings longer
-   than INT_MAX.  */
 typedef int regoff_t;
-#endif
 
 
 #ifdef __USE_GNU
@@ -496,15 +431,15 @@ typedef int regoff_t;
    regex.texinfo for a full description of what registers match.  */
 struct re_registers
 {
-  __re_size_t num_regs;
+  unsigned num_regs;
   regoff_t *start;
   regoff_t *end;
 };
 
 
-/* If 'regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
-   're_match_2' returns information about at least this many registers
-   the first time a 'regs' structure is passed.  */
+/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
+   `re_match_2' returns information about at least this many registers
+   the first time a `regs' structure is passed.  */
 # ifndef RE_NREGS
 #  define RE_NREGS 30
 # endif
@@ -512,7 +447,7 @@ struct re_registers
 
 
 /* POSIX specification for registers.  Aside from the different names than
-   're_registers', POSIX uses an array of structures, instead of a
+   `re_registers', POSIX uses an array of structures, instead of a
    structure of arrays.  */
 typedef struct
 {
@@ -524,17 +459,17 @@ typedef struct
 
 #ifdef __USE_GNU
 /* Sets the current default syntax to SYNTAX, and return the old syntax.
-   You can also simply assign to the 're_syntax_options' variable.  */
+   You can also simply assign to the `re_syntax_options' variable.  */
 extern reg_syntax_t re_set_syntax (reg_syntax_t __syntax);
 
 /* Compile the regular expression PATTERN, with length LENGTH
-   and syntax given by the global 're_syntax_options', into the buffer
+   and syntax given by the global `re_syntax_options', into the buffer
    BUFFER.  Return NULL if successful, and an error string if not.
 
-   To free the allocated storage, you must call 'regfree' on BUFFER.
-   Note that the translate table must either have been initialized by
-   'regcomp', with a malloc'ed value, or set to NULL before calling
-   'regfree'.  */
+   To free the allocated storage, you must call `regfree' on BUFFER.
+   Note that the translate table must either have been initialised by
+   `regcomp', with a malloc'ed value, or set to NULL before calling
+   `regfree'.  */
 extern const char *re_compile_pattern (const char *__pattern, size_t __length,
 				       struct re_pattern_buffer *__buffer);
 
@@ -550,52 +485,47 @@ extern int re_compile_fastmap (struct re_pattern_buffer *__buffer);
    characters.  Return the starting position of the match, -1 for no
    match, or -2 for an internal error.  Also return register
    information in REGS (if REGS and BUFFER->no_sub are nonzero).  */
-extern regoff_t re_search (struct re_pattern_buffer *__buffer,
-			   const char *__String, regoff_t __length,
-			   regoff_t __start, regoff_t __range,
-			   struct re_registers *__regs);
+extern int re_search (struct re_pattern_buffer *__buffer, const char *__string,
+		      int __length, int __start, int __range,
+		      struct re_registers *__regs);
 
 
-/* Like 're_search', but search in the concatenation of STRING1 and
+/* Like `re_search', but search in the concatenation of STRING1 and
    STRING2.  Also, stop searching at index START + STOP.  */
-extern regoff_t re_search_2 (struct re_pattern_buffer *__buffer,
-			     const char *__string1, regoff_t __length1,
-			     const char *__string2, regoff_t __length2,
-			     regoff_t __start, regoff_t __range,
-			     struct re_registers *__regs,
-			     regoff_t __stop);
+extern int re_search_2 (struct re_pattern_buffer *__buffer,
+			const char *__string1, int __length1,
+			const char *__string2, int __length2, int __start,
+			int __range, struct re_registers *__regs, int __stop);
 
 
-/* Like 're_search', but return how many characters in STRING the regexp
+/* Like `re_search', but return how many characters in STRING the regexp
    in BUFFER matched, starting at position START.  */
-extern regoff_t re_match (struct re_pattern_buffer *__buffer,
-			  const char *__String, regoff_t __length,
-			  regoff_t __start, struct re_registers *__regs);
+extern int re_match (struct re_pattern_buffer *__buffer, const char *__string,
+		     int __length, int __start, struct re_registers *__regs);
 
 
-/* Relates to 're_match' as 're_search_2' relates to 're_search'.  */
-extern regoff_t re_match_2 (struct re_pattern_buffer *__buffer,
-			    const char *__string1, regoff_t __length1,
-			    const char *__string2, regoff_t __length2,
-			    regoff_t __start, struct re_registers *__regs,
-			    regoff_t __stop);
+/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */
+extern int re_match_2 (struct re_pattern_buffer *__buffer,
+		       const char *__string1, int __length1,
+		       const char *__string2, int __length2, int __start,
+		       struct re_registers *__regs, int __stop);
 
 
 /* Set REGS to hold NUM_REGS registers, storing them in STARTS and
    ENDS.  Subsequent matches using BUFFER and REGS will use this memory
    for recording register information.  STARTS and ENDS must be
-   allocated with malloc, and must each be at least 'NUM_REGS * sizeof
+   allocated with malloc, and must each be at least `NUM_REGS * sizeof
    (regoff_t)' bytes long.
 
    If NUM_REGS == 0, then subsequent matches should allocate their own
    register data.
 
    Unless this function is called, the first search or match using
-   BUFFER will allocate its own register data, without
+   PATTERN_BUFFER will allocate its own register data, without
    freeing the old data.  */
 extern void re_set_registers (struct re_pattern_buffer *__buffer,
 			      struct re_registers *__regs,
-			      __re_size_t __num_regs,
+			      unsigned int __num_regs,
 			      regoff_t *__starts, regoff_t *__ends);
 #endif	/* Use GNU */
 
@@ -607,46 +537,39 @@ extern int re_exec (const char *);
 # endif
 #endif
 
-/* For plain 'restrict', use glibc's __restrict if defined.
-   Otherwise, GCC 2.95 and later have "__restrict"; C99 compilers have
-   "restrict", and "configure" may have defined "restrict".
-   Other compilers use __restrict, __restrict__, and _Restrict, and
-   'configure' might #define 'restrict' to those words, so pick a
-   different name.  */
-#ifndef _Restrict_
-# if defined __restrict || 2 < __GNUC__ + (95 <= __GNUC_MINOR__)
-#  define _Restrict_ __restrict
-# elif 199901L <= __STDC_VERSION__ || defined restrict
-#  define _Restrict_ restrict
-# else
-#  define _Restrict_
+/* GCC 2.95 and later have "__restrict"; C99 compilers have
+   "restrict", and "configure" may have defined "restrict".  */
+#ifndef __restrict
+# if ! (2 < __GNUC__ || (2 == __GNUC__ && 95 <= __GNUC_MINOR__))
+#  if defined restrict || 199901L <= __STDC_VERSION__
+#   define __restrict restrict
+#  else
+#   define __restrict
+#  endif
 # endif
 #endif
-/* For [restrict], use glibc's __restrict_arr if available.
-   Otherwise, GCC 3.1 (not in C++ mode) and C99 support [restrict].  */
-#ifndef _Restrict_arr_
-# ifdef __restrict_arr
-#  define _Restrict_arr_ __restrict_arr
-# elif ((199901L <= __STDC_VERSION__ || 3 < __GNUC__ + (1 <= __GNUC_MINOR__)) \
-        && !defined __GNUG__)
-#  define _Restrict_arr_ _Restrict_
+/* gcc 3.1 and up support the [restrict] syntax.  */
+#ifndef __restrict_arr
+# if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)) \
+     && !defined __GNUG__
+#  define __restrict_arr __restrict
 # else
-#  define _Restrict_arr_
+#  define __restrict_arr
 # endif
 #endif
 
 /* POSIX compatibility.  */
-extern int regcomp (regex_t *_Restrict_ __preg,
-		    const char *_Restrict_ __pattern,
+extern int regcomp (regex_t *__restrict __preg,
+		    const char *__restrict __pattern,
 		    int __cflags);
 
-extern int regexec (const regex_t *_Restrict_ __preg,
-		    const char *_Restrict_ __String, size_t __nmatch,
-		    regmatch_t __pmatch[_Restrict_arr_],
+extern int regexec (const regex_t *__restrict __preg,
+		    const char *__restrict __string, size_t __nmatch,
+		    regmatch_t __pmatch[__restrict_arr],
 		    int __eflags);
 
-extern size_t regerror (int __errcode, const regex_t *_Restrict_ __preg,
-			char *_Restrict_ __errbuf, size_t __errbuf_size);
+extern size_t regerror (int __errcode, const regex_t *__restrict __preg,
+			char *__restrict __errbuf, size_t __errbuf_size);
 
 extern void regfree (regex_t *__preg);
 
diff --git a/posix/regex_internal.c b/posix/regex_internal.c
index 7f0083b918..906208343b 100644
--- a/posix/regex_internal.c
+++ b/posix/regex_internal.c
@@ -15,29 +15,19 @@
 
    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
+   <http://www.gnu.org/licenses/>.  */
 
-static void re_string_construct_common (const char *str, Idx len,
+static void re_string_construct_common (const char *str, int len,
 					re_string_t *pstr,
-					RE_TRANSLATE_TYPE trans, bool icase,
+					RE_TRANSLATE_TYPE trans, int icase,
 					const re_dfa_t *dfa);
 static re_dfastate_t *create_ci_newstate (const re_dfa_t *dfa,
 					  const re_node_set *nodes,
-					  re_hashval_t hash);
+					  unsigned int hash);
 static re_dfastate_t *create_cd_newstate (const re_dfa_t *dfa,
 					  const re_node_set *nodes,
 					  unsigned int context,
-					  re_hashval_t hash);
-static reg_errcode_t re_string_realloc_buffers (re_string_t *pstr,
-						Idx new_buf_len);
-#ifdef RE_ENABLE_I18N
-static void build_wcs_buffer (re_string_t *pstr);
-static reg_errcode_t build_wcs_upper_buffer (re_string_t *pstr);
-#endif /* RE_ENABLE_I18N */
-static void build_upper_buffer (re_string_t *pstr);
-static void re_string_translate_buffer (re_string_t *pstr);
-static unsigned int re_string_context_at (const re_string_t *input, Idx idx,
-					  int eflags) __attribute__ ((pure));
+					  unsigned int hash);
 
 /* Functions for string operation.  */
 
@@ -46,11 +36,11 @@ static unsigned int re_string_context_at (const re_string_t *input, Idx idx,
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-re_string_allocate (re_string_t *pstr, const char *str, Idx len, Idx init_len,
-		    RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)
+re_string_allocate (re_string_t *pstr, const char *str, int len, int init_len,
+		    RE_TRANSLATE_TYPE trans, int icase, const re_dfa_t *dfa)
 {
   reg_errcode_t ret;
-  Idx init_buf_len;
+  int init_buf_len;
 
   /* Ensure at least one character fits into the buffers.  */
   if (init_len < dfa->mb_cur_max)
@@ -74,8 +64,8 @@ re_string_allocate (re_string_t *pstr, const char *str, Idx len, Idx init_len,
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-re_string_construct (re_string_t *pstr, const char *str, Idx len,
-		     RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)
+re_string_construct (re_string_t *pstr, const char *str, int len,
+		     RE_TRANSLATE_TYPE trans, int icase, const re_dfa_t *dfa)
 {
   reg_errcode_t ret;
   memset (pstr, '\0', sizeof (re_string_t));
@@ -137,7 +127,7 @@ re_string_construct (re_string_t *pstr, const char *str, Idx len,
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-re_string_realloc_buffers (re_string_t *pstr, Idx new_buf_len)
+re_string_realloc_buffers (re_string_t *pstr, int new_buf_len)
 {
 #ifdef RE_ENABLE_I18N
   if (pstr->mb_cur_max > 1)
@@ -145,8 +135,8 @@ re_string_realloc_buffers (re_string_t *pstr, Idx new_buf_len)
       wint_t *new_wcs;
 
       /* Avoid overflow in realloc.  */
-      const size_t max_object_size = MAX (sizeof (wint_t), sizeof (Idx));
-      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_buf_len, 0))
+      const size_t max_object_size = MAX (sizeof (wint_t), sizeof (int));
+      if (BE (SIZE_MAX / max_object_size < new_buf_len, 0))
 	return REG_ESPACE;
 
       new_wcs = re_realloc (pstr->wcs, wint_t, new_buf_len);
@@ -155,7 +145,7 @@ re_string_realloc_buffers (re_string_t *pstr, Idx new_buf_len)
       pstr->wcs = new_wcs;
       if (pstr->offsets != NULL)
 	{
-	  Idx *new_offsets = re_realloc (pstr->offsets, Idx, new_buf_len);
+	  int *new_offsets = re_realloc (pstr->offsets, int, new_buf_len);
 	  if (BE (new_offsets == NULL, 0))
 	    return REG_ESPACE;
 	  pstr->offsets = new_offsets;
@@ -176,15 +166,15 @@ re_string_realloc_buffers (re_string_t *pstr, Idx new_buf_len)
 
 
 static void
-re_string_construct_common (const char *str, Idx len, re_string_t *pstr,
-			    RE_TRANSLATE_TYPE trans, bool icase,
+re_string_construct_common (const char *str, int len, re_string_t *pstr,
+			    RE_TRANSLATE_TYPE trans, int icase,
 			    const re_dfa_t *dfa)
 {
   pstr->raw_mbs = (const unsigned char *) str;
   pstr->len = len;
   pstr->raw_len = len;
   pstr->trans = trans;
-  pstr->icase = icase;
+  pstr->icase = icase ? 1 : 0;
   pstr->mbs_allocated = (trans != NULL || icase);
   pstr->mb_cur_max = dfa->mb_cur_max;
   pstr->is_utf8 = dfa->is_utf8;
@@ -216,7 +206,7 @@ build_wcs_buffer (re_string_t *pstr)
   unsigned char buf[64];
 #endif
   mbstate_t prev_st;
-  Idx byte_idx, end_idx, remain_len;
+  int byte_idx, end_idx, remain_len;
   size_t mbclen;
 
   /* Build the buffers from pstr->valid_len to either pstr->len or
@@ -279,7 +269,7 @@ __attribute_warn_unused_result__
 build_wcs_upper_buffer (re_string_t *pstr)
 {
   mbstate_t prev_st;
-  Idx src_idx, byte_idx, end_idx, remain_len;
+  int src_idx, byte_idx, end_idx, remain_len;
   size_t mbclen;
 #ifdef _LIBC
   char buf[MB_LEN_MAX];
@@ -317,13 +307,14 @@ build_wcs_upper_buffer (re_string_t *pstr)
 	  mbclen = __mbrtowc (&wc,
 			      ((const char *) pstr->raw_mbs + pstr->raw_mbs_idx
 			       + byte_idx), remain_len, &pstr->cur_state);
-	  if (BE (mbclen < (size_t) -2, 1))
+	  if (BE (mbclen + 2 > 2, 1))
 	    {
-	      wchar_t wcu = __towupper (wc);
-	      if (wcu != wc)
+	      wchar_t wcu = wc;
+	      if (__iswlower (wc))
 		{
 		  size_t mbcdlen;
 
+		  wcu = __towupper (wc);
 		  mbcdlen = __wcrtomb (buf, wcu, &prev_st);
 		  if (BE (mbclen == mbcdlen, 1))
 		    memcpy (pstr->mbs + byte_idx, buf, mbclen);
@@ -386,13 +377,14 @@ build_wcs_upper_buffer (re_string_t *pstr)
 	else
 	  p = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + src_idx;
 	mbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);
-	if (BE (mbclen < (size_t) -2, 1))
+	if (BE (mbclen + 2 > 2, 1))
 	  {
-	    wchar_t wcu = __towupper (wc);
-	    if (wcu != wc)
+	    wchar_t wcu = wc;
+	    if (__iswlower (wc))
 	      {
 		size_t mbcdlen;
 
+		wcu = __towupper (wc);
 		mbcdlen = __wcrtomb ((char *) buf, wcu, &prev_st);
 		if (BE (mbclen == mbcdlen, 1))
 		  memcpy (pstr->mbs + byte_idx, buf, mbclen);
@@ -408,7 +400,7 @@ build_wcs_upper_buffer (re_string_t *pstr)
 
 		    if (pstr->offsets == NULL)
 		      {
-			pstr->offsets = re_malloc (Idx, pstr->bufs_len);
+			pstr->offsets = re_malloc (int, pstr->bufs_len);
 
 			if (pstr->offsets == NULL)
 			  return REG_ESPACE;
@@ -491,11 +483,11 @@ build_wcs_upper_buffer (re_string_t *pstr)
 /* Skip characters until the index becomes greater than NEW_RAW_IDX.
    Return the index.  */
 
-static Idx
-re_string_skip_chars (re_string_t *pstr, Idx new_raw_idx, wint_t *last_wc)
+static int
+re_string_skip_chars (re_string_t *pstr, int new_raw_idx, wint_t *last_wc)
 {
   mbstate_t prev_st;
-  Idx rawbuf_idx;
+  int rawbuf_idx;
   size_t mbclen;
   wint_t wc = WEOF;
 
@@ -504,11 +496,11 @@ re_string_skip_chars (re_string_t *pstr, Idx new_raw_idx, wint_t *last_wc)
        rawbuf_idx < new_raw_idx;)
     {
       wchar_t wc2;
-      Idx remain_len = pstr->raw_len - rawbuf_idx;
+      int remain_len = pstr->raw_len - rawbuf_idx;
       prev_st = pstr->cur_state;
       mbclen = __mbrtowc (&wc2, (const char *) pstr->raw_mbs + rawbuf_idx,
 			  remain_len, &pstr->cur_state);
-      if (BE (mbclen == (size_t) -2 || mbclen == (size_t) -1 || mbclen == 0, 0))
+      if (BE ((ssize_t) mbclen <= 0, 0))
 	{
 	  /* We treat these cases as a single byte character.  */
 	  if (mbclen == 0 || remain_len == 0)
@@ -519,7 +511,7 @@ re_string_skip_chars (re_string_t *pstr, Idx new_raw_idx, wint_t *last_wc)
 	  pstr->cur_state = prev_st;
 	}
       else
-	wc = wc2;
+	wc = (wint_t) wc2;
       /* Then proceed the next character.  */
       rawbuf_idx += mbclen;
     }
@@ -534,7 +526,7 @@ re_string_skip_chars (re_string_t *pstr, Idx new_raw_idx, wint_t *last_wc)
 static void
 build_upper_buffer (re_string_t *pstr)
 {
-  Idx char_idx, end_idx;
+  int char_idx, end_idx;
   end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;
 
   for (char_idx = pstr->valid_len; char_idx < end_idx; ++char_idx)
@@ -542,7 +534,10 @@ build_upper_buffer (re_string_t *pstr)
       int ch = pstr->raw_mbs[pstr->raw_mbs_idx + char_idx];
       if (BE (pstr->trans != NULL, 0))
 	ch = pstr->trans[ch];
-      pstr->mbs[char_idx] = toupper (ch);
+      if (islower (ch))
+	pstr->mbs[char_idx] = toupper (ch);
+      else
+	pstr->mbs[char_idx] = ch;
     }
   pstr->valid_len = char_idx;
   pstr->valid_raw_len = char_idx;
@@ -553,7 +548,7 @@ build_upper_buffer (re_string_t *pstr)
 static void
 re_string_translate_buffer (re_string_t *pstr)
 {
-  Idx buf_idx, end_idx;
+  int buf_idx, end_idx;
   end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;
 
   for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)
@@ -572,13 +567,10 @@ re_string_translate_buffer (re_string_t *pstr)
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-re_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)
+re_string_reconstruct (re_string_t *pstr, int idx, int eflags)
 {
-  Idx offset;
-
-  if (BE (pstr->raw_mbs_idx <= idx, 0))
-    offset = idx - pstr->raw_mbs_idx;
-  else
+  int offset = idx - pstr->raw_mbs_idx;
+  if (BE (offset < 0, 0))
     {
       /* Reset buffer.  */
 #ifdef RE_ENABLE_I18N
@@ -607,7 +599,7 @@ re_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)
 #ifdef RE_ENABLE_I18N
 	  if (BE (pstr->offsets_needed, 0))
 	    {
-	      Idx low = 0, high = pstr->valid_len, mid;
+	      int low = 0, high = pstr->valid_len, mid;
 	      do
 		{
 		  mid = (high + low) / 2;
@@ -691,7 +683,7 @@ re_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)
 	{
 #ifdef RE_ENABLE_I18N
 	  /* No, skip all characters until IDX.  */
-	  Idx prev_valid_len = pstr->valid_len;
+	  int prev_valid_len = pstr->valid_len;
 
 	  if (BE (pstr->offsets_needed, 0))
 	    {
@@ -704,7 +696,7 @@ re_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)
 #ifdef RE_ENABLE_I18N
 	  if (pstr->mb_cur_max > 1)
 	    {
-	      Idx wcs_idx;
+	      int wcs_idx;
 	      wint_t wc = WEOF;
 
 	      if (pstr->is_utf8)
@@ -734,7 +726,7 @@ re_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)
 			{
 			  mbstate_t cur_state;
 			  wchar_t wc2;
-			  Idx mlen = raw + pstr->len - p;
+			  int mlen = raw + pstr->len - p;
 			  unsigned char buf[6];
 			  size_t mbclen;
 
@@ -834,11 +826,10 @@ re_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)
 }
 
 static unsigned char
-__attribute__ ((pure))
-re_string_peek_byte_case (const re_string_t *pstr, Idx idx)
+__attribute ((pure))
+re_string_peek_byte_case (const re_string_t *pstr, int idx)
 {
-  int ch;
-  Idx off;
+  int ch, off;
 
   /* Handle the common (easiest) cases first.  */
   if (BE (!pstr->mbs_allocated, 1))
@@ -879,8 +870,7 @@ re_string_fetch_byte_case (re_string_t *pstr)
 #ifdef RE_ENABLE_I18N
   if (pstr->offsets_needed)
     {
-      Idx off;
-      int ch;
+      int off, ch;
 
       /* For tr_TR.UTF-8 [[:islower:]] there is
 	 [[: CAPITAL LETTER I WITH DOT lower:]] in mbs.  Skip
@@ -921,7 +911,7 @@ re_string_destruct (re_string_t *pstr)
 /* Return the context at IDX in INPUT.  */
 
 static unsigned int
-re_string_context_at (const re_string_t *input, Idx idx, int eflags)
+re_string_context_at (const re_string_t *input, int idx, int eflags)
 {
   int c;
   if (BE (idx < 0, 0))
@@ -935,7 +925,7 @@ re_string_context_at (const re_string_t *input, Idx idx, int eflags)
   if (input->mb_cur_max > 1)
     {
       wint_t wc;
-      Idx wc_idx = idx;
+      int wc_idx = idx;
       while(input->wcs[wc_idx] == WEOF)
 	{
 #if defined DEBUG && DEBUG
@@ -966,23 +956,23 @@ re_string_context_at (const re_string_t *input, Idx idx, int eflags)
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-re_node_set_alloc (re_node_set *set, Idx size)
+re_node_set_alloc (re_node_set *set, int size)
 {
   set->alloc = size;
   set->nelem = 0;
-  set->elems = re_malloc (Idx, size);
-  if (BE (set->elems == NULL, 0) && (MALLOC_0_IS_NONNULL || size != 0))
+  set->elems = re_malloc (int, size);
+  if (BE (set->elems == NULL, 0))
     return REG_ESPACE;
   return REG_NOERROR;
 }
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-re_node_set_init_1 (re_node_set *set, Idx elem)
+re_node_set_init_1 (re_node_set *set, int elem)
 {
   set->alloc = 1;
   set->nelem = 1;
-  set->elems = re_malloc (Idx, 1);
+  set->elems = re_malloc (int, 1);
   if (BE (set->elems == NULL, 0))
     {
       set->alloc = set->nelem = 0;
@@ -994,10 +984,10 @@ re_node_set_init_1 (re_node_set *set, Idx elem)
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-re_node_set_init_2 (re_node_set *set, Idx elem1, Idx elem2)
+re_node_set_init_2 (re_node_set *set, int elem1, int elem2)
 {
   set->alloc = 2;
-  set->elems = re_malloc (Idx, 2);
+  set->elems = re_malloc (int, 2);
   if (BE (set->elems == NULL, 0))
     return REG_ESPACE;
   if (elem1 == elem2)
@@ -1030,13 +1020,13 @@ re_node_set_init_copy (re_node_set *dest, const re_node_set *src)
   if (src->nelem > 0)
     {
       dest->alloc = dest->nelem;
-      dest->elems = re_malloc (Idx, dest->alloc);
+      dest->elems = re_malloc (int, dest->alloc);
       if (BE (dest->elems == NULL, 0))
 	{
 	  dest->alloc = dest->nelem = 0;
 	  return REG_ESPACE;
 	}
-      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));
+      memcpy (dest->elems, src->elems, src->nelem * sizeof (int));
     }
   else
     re_node_set_init_empty (dest);
@@ -1052,7 +1042,7 @@ __attribute_warn_unused_result__
 re_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,
 			   const re_node_set *src2)
 {
-  Idx i1, i2, is, id, delta, sbase;
+  int i1, i2, is, id, delta, sbase;
   if (src1->nelem == 0 || src2->nelem == 0)
     return REG_NOERROR;
 
@@ -1060,8 +1050,8 @@ re_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,
      conservative estimate.  */
   if (src1->nelem + src2->nelem + dest->nelem > dest->alloc)
     {
-      Idx new_alloc = src1->nelem + src2->nelem + dest->alloc;
-      Idx *new_elems = re_realloc (dest->elems, Idx, new_alloc);
+      int new_alloc = src1->nelem + src2->nelem + dest->alloc;
+      int *new_elems = re_realloc (dest->elems, int, new_alloc);
       if (BE (new_elems == NULL, 0))
 	return REG_ESPACE;
       dest->elems = new_elems;
@@ -1083,7 +1073,7 @@ re_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,
 	    --id;
 
 	  if (id < 0 || dest->elems[id] != src1->elems[i1])
-            dest->elems[--sbase] = src1->elems[i1];
+	    dest->elems[--sbase] = src1->elems[i1];
 
 	  if (--i1 < 0 || --i2 < 0)
 	    break;
@@ -1130,7 +1120,7 @@ re_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,
       }
 
   /* Copy remaining SRC elements.  */
-  memcpy (dest->elems, dest->elems + sbase, delta * sizeof (Idx));
+  memcpy (dest->elems, dest->elems + sbase, delta * sizeof (int));
 
   return REG_NOERROR;
 }
@@ -1143,11 +1133,11 @@ __attribute_warn_unused_result__
 re_node_set_init_union (re_node_set *dest, const re_node_set *src1,
 			const re_node_set *src2)
 {
-  Idx i1, i2, id;
+  int i1, i2, id;
   if (src1 != NULL && src1->nelem > 0 && src2 != NULL && src2->nelem > 0)
     {
       dest->alloc = src1->nelem + src2->nelem;
-      dest->elems = re_malloc (Idx, dest->alloc);
+      dest->elems = re_malloc (int, dest->alloc);
       if (BE (dest->elems == NULL, 0))
 	return REG_ESPACE;
     }
@@ -1175,13 +1165,13 @@ re_node_set_init_union (re_node_set *dest, const re_node_set *src1,
   if (i1 < src1->nelem)
     {
       memcpy (dest->elems + id, src1->elems + i1,
-	     (src1->nelem - i1) * sizeof (Idx));
+	     (src1->nelem - i1) * sizeof (int));
       id += src1->nelem - i1;
     }
   else if (i2 < src2->nelem)
     {
       memcpy (dest->elems + id, src2->elems + i2,
-	     (src2->nelem - i2) * sizeof (Idx));
+	     (src2->nelem - i2) * sizeof (int));
       id += src2->nelem - i2;
     }
   dest->nelem = id;
@@ -1195,13 +1185,13 @@ static reg_errcode_t
 __attribute_warn_unused_result__
 re_node_set_merge (re_node_set *dest, const re_node_set *src)
 {
-  Idx is, id, sbase, delta;
+  int is, id, sbase, delta;
   if (src == NULL || src->nelem == 0)
     return REG_NOERROR;
   if (dest->alloc < 2 * src->nelem + dest->nelem)
     {
-      Idx new_alloc = 2 * (src->nelem + dest->alloc);
-      Idx *new_buffer = re_realloc (dest->elems, Idx, new_alloc);
+      int new_alloc = 2 * (src->nelem + dest->alloc);
+      int *new_buffer = re_realloc (dest->elems, int, new_alloc);
       if (BE (new_buffer == NULL, 0))
 	return REG_ESPACE;
       dest->elems = new_buffer;
@@ -1211,7 +1201,7 @@ re_node_set_merge (re_node_set *dest, const re_node_set *src)
   if (BE (dest->nelem == 0, 0))
     {
       dest->nelem = src->nelem;
-      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));
+      memcpy (dest->elems, src->elems, src->nelem * sizeof (int));
       return REG_NOERROR;
     }
 
@@ -1232,7 +1222,7 @@ re_node_set_merge (re_node_set *dest, const re_node_set *src)
     {
       /* If DEST is exhausted, the remaining items of SRC must be unique.  */
       sbase -= is + 1;
-      memcpy (dest->elems + sbase, src->elems, (is + 1) * sizeof (Idx));
+      memcpy (dest->elems + sbase, src->elems, (is + 1) * sizeof (int));
     }
 
   id = dest->nelem - 1;
@@ -1261,7 +1251,7 @@ re_node_set_merge (re_node_set *dest, const re_node_set *src)
 	    {
 	      /* Copy remaining SRC elements.  */
 	      memcpy (dest->elems, dest->elems + sbase,
-		      delta * sizeof (Idx));
+		      delta * sizeof (int));
 	      break;
 	    }
 	}
@@ -1272,33 +1262,38 @@ re_node_set_merge (re_node_set *dest, const re_node_set *src)
 
 /* Insert the new element ELEM to the re_node_set* SET.
    SET should not already have ELEM.
-   Return true if successful.  */
+   return -1 if an error is occured, return 1 otherwise.  */
 
-static bool
+static int
 __attribute_warn_unused_result__
-re_node_set_insert (re_node_set *set, Idx elem)
+re_node_set_insert (re_node_set *set, int elem)
 {
-  Idx idx;
+  int idx;
   /* In case the set is empty.  */
   if (set->alloc == 0)
-    return BE (re_node_set_init_1 (set, elem) == REG_NOERROR, 1);
+    {
+      if (BE (re_node_set_init_1 (set, elem) == REG_NOERROR, 1))
+	return 1;
+      else
+	return -1;
+    }
 
   if (BE (set->nelem, 0) == 0)
     {
       /* We already guaranteed above that set->alloc != 0.  */
       set->elems[0] = elem;
       ++set->nelem;
-      return true;
+      return 1;
     }
 
   /* Realloc if we need.  */
   if (set->alloc == set->nelem)
     {
-      Idx *new_elems;
+      int *new_elems;
       set->alloc = set->alloc * 2;
-      new_elems = re_realloc (set->elems, Idx, set->alloc);
+      new_elems = re_realloc (set->elems, int, set->alloc);
       if (BE (new_elems == NULL, 0))
-	return false;
+	return -1;
       set->elems = new_elems;
     }
 
@@ -1319,56 +1314,56 @@ re_node_set_insert (re_node_set *set, Idx elem)
   /* Insert the new element.  */
   set->elems[idx] = elem;
   ++set->nelem;
-  return true;
+  return 1;
 }
 
 /* Insert the new element ELEM to the re_node_set* SET.
    SET should not already have any element greater than or equal to ELEM.
-   Return true if successful.  */
+   Return -1 if an error is occured, return 1 otherwise.  */
 
-static bool
+static int
 __attribute_warn_unused_result__
-re_node_set_insert_last (re_node_set *set, Idx elem)
+re_node_set_insert_last (re_node_set *set, int elem)
 {
   /* Realloc if we need.  */
   if (set->alloc == set->nelem)
     {
-      Idx *new_elems;
+      int *new_elems;
       set->alloc = (set->alloc + 1) * 2;
-      new_elems = re_realloc (set->elems, Idx, set->alloc);
+      new_elems = re_realloc (set->elems, int, set->alloc);
       if (BE (new_elems == NULL, 0))
-	return false;
+	return -1;
       set->elems = new_elems;
     }
 
   /* Insert the new element.  */
   set->elems[set->nelem++] = elem;
-  return true;
+  return 1;
 }
 
 /* Compare two node sets SET1 and SET2.
-   Return true if SET1 and SET2 are equivalent.  */
+   return 1 if SET1 and SET2 are equivalent, return 0 otherwise.  */
 
-static bool
-__attribute__ ((pure))
+static int
+__attribute ((pure))
 re_node_set_compare (const re_node_set *set1, const re_node_set *set2)
 {
-  Idx i;
+  int i;
   if (set1 == NULL || set2 == NULL || set1->nelem != set2->nelem)
-    return false;
+    return 0;
   for (i = set1->nelem ; --i >= 0 ; )
     if (set1->elems[i] != set2->elems[i])
-      return false;
-  return true;
+      return 0;
+  return 1;
 }
 
 /* Return (idx + 1) if SET contains the element ELEM, return 0 otherwise.  */
 
-static Idx
-__attribute__ ((pure))
-re_node_set_contains (const re_node_set *set, Idx elem)
+static int
+__attribute ((pure))
+re_node_set_contains (const re_node_set *set, int elem)
 {
-  __re_size_t idx, right, mid;
+  unsigned int idx, right, mid;
   if (set->nelem <= 0)
     return 0;
 
@@ -1387,7 +1382,7 @@ re_node_set_contains (const re_node_set *set, Idx elem)
 }
 
 static void
-re_node_set_remove_at (re_node_set *set, Idx idx)
+re_node_set_remove_at (re_node_set *set, int idx)
 {
   if (idx < 0 || idx >= set->nelem)
     return;
@@ -1398,42 +1393,37 @@ re_node_set_remove_at (re_node_set *set, Idx idx)
 
 
 /* Add the token TOKEN to dfa->nodes, and return the index of the token.
-   Or return -1 if an error occurred.  */
+   Or return -1, if an error will be occured.  */
 
-static Idx
+static int
 re_dfa_add_node (re_dfa_t *dfa, re_token_t token)
 {
+  int type = token.type;
   if (BE (dfa->nodes_len >= dfa->nodes_alloc, 0))
     {
       size_t new_nodes_alloc = dfa->nodes_alloc * 2;
-      Idx *new_nexts, *new_indices;
+      int *new_nexts, *new_indices;
       re_node_set *new_edests, *new_eclosures;
       re_token_t *new_nodes;
 
       /* Avoid overflows in realloc.  */
       const size_t max_object_size = MAX (sizeof (re_token_t),
 					  MAX (sizeof (re_node_set),
-					       sizeof (Idx)));
-      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_nodes_alloc, 0))
+					       sizeof (int)));
+      if (BE (SIZE_MAX / max_object_size < new_nodes_alloc, 0))
 	return -1;
 
       new_nodes = re_realloc (dfa->nodes, re_token_t, new_nodes_alloc);
       if (BE (new_nodes == NULL, 0))
 	return -1;
       dfa->nodes = new_nodes;
-      new_nexts = re_realloc (dfa->nexts, Idx, new_nodes_alloc);
-      new_indices = re_realloc (dfa->org_indices, Idx, new_nodes_alloc);
+      new_nexts = re_realloc (dfa->nexts, int, new_nodes_alloc);
+      new_indices = re_realloc (dfa->org_indices, int, new_nodes_alloc);
       new_edests = re_realloc (dfa->edests, re_node_set, new_nodes_alloc);
       new_eclosures = re_realloc (dfa->eclosures, re_node_set, new_nodes_alloc);
       if (BE (new_nexts == NULL || new_indices == NULL
 	      || new_edests == NULL || new_eclosures == NULL, 0))
-	{
-	   re_free (new_nexts);
-	   re_free (new_indices);
-	   re_free (new_edests);
-	   re_free (new_eclosures);
-	   return -1;
-	}
+	return -1;
       dfa->nexts = new_nexts;
       dfa->org_indices = new_indices;
       dfa->edests = new_edests;
@@ -1444,8 +1434,7 @@ re_dfa_add_node (re_dfa_t *dfa, re_token_t token)
   dfa->nodes[dfa->nodes_len].constraint = 0;
 #ifdef RE_ENABLE_I18N
   dfa->nodes[dfa->nodes_len].accept_mb =
-    ((token.type == OP_PERIOD && dfa->mb_cur_max > 1)
-     || token.type == COMPLEX_BRACKET);
+    (type == OP_PERIOD && dfa->mb_cur_max > 1) || type == COMPLEX_BRACKET;
 #endif
   dfa->nexts[dfa->nodes_len] = -1;
   re_node_set_init_empty (dfa->edests + dfa->nodes_len);
@@ -1453,11 +1442,11 @@ re_dfa_add_node (re_dfa_t *dfa, re_token_t token)
   return dfa->nodes_len++;
 }
 
-static re_hashval_t
+static inline unsigned int
 calc_state_hash (const re_node_set *nodes, unsigned int context)
 {
-  re_hashval_t hash = nodes->nelem + context;
-  Idx i;
+  unsigned int hash = nodes->nelem + context;
+  int i;
   for (i = 0 ; i < nodes->nelem ; i++)
     hash += nodes->elems[i];
   return hash;
@@ -1477,14 +1466,10 @@ __attribute_warn_unused_result__
 re_acquire_state (reg_errcode_t *err, const re_dfa_t *dfa,
 		  const re_node_set *nodes)
 {
-  re_hashval_t hash;
+  unsigned int hash;
   re_dfastate_t *new_state;
   struct re_state_table_entry *spot;
-  Idx i;
-#if defined GCC_LINT || defined lint
-  /* Suppress bogus uninitialized-variable warnings.  */
-  *err = REG_NOERROR;
-#endif
+  int i;
   if (BE (nodes->nelem == 0, 0))
     {
       *err = REG_NOERROR;
@@ -1525,14 +1510,10 @@ __attribute_warn_unused_result__
 re_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,
 			  const re_node_set *nodes, unsigned int context)
 {
-  re_hashval_t hash;
+  unsigned int hash;
   re_dfastate_t *new_state;
   struct re_state_table_entry *spot;
-  Idx i;
-#if defined GCC_LINT || defined lint
-  /* Suppress bogus uninitialized-variable warnings.  */
-  *err = REG_NOERROR;
-#endif
+  int i;
   if (nodes->nelem == 0)
     {
       *err = REG_NOERROR;
@@ -1549,7 +1530,7 @@ re_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,
 	  && re_node_set_compare (state->entrance_nodes, nodes))
 	return state;
     }
-  /* There are no appropriate state in 'dfa', create the new one.  */
+  /* There are no appropriate state in `dfa', create the new one.  */
   new_state = create_cd_newstate (dfa, nodes, context, hash);
   if (BE (new_state == NULL, 0))
     *err = REG_ESPACE;
@@ -1564,11 +1545,11 @@ re_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,
 static reg_errcode_t
 __attribute_warn_unused_result__
 register_state (const re_dfa_t *dfa, re_dfastate_t *newstate,
-		re_hashval_t hash)
+		unsigned int hash)
 {
   struct re_state_table_entry *spot;
   reg_errcode_t err;
-  Idx i;
+  int i;
 
   newstate->hash = hash;
   err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);
@@ -1576,16 +1557,16 @@ register_state (const re_dfa_t *dfa, re_dfastate_t *newstate,
     return REG_ESPACE;
   for (i = 0; i < newstate->nodes.nelem; i++)
     {
-      Idx elem = newstate->nodes.elems[i];
+      int elem = newstate->nodes.elems[i];
       if (!IS_EPSILON_NODE (dfa->nodes[elem].type))
-	if (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))
+	if (re_node_set_insert_last (&newstate->non_eps_nodes, elem) < 0)
 	  return REG_ESPACE;
     }
 
   spot = dfa->state_table + (hash & dfa->state_hash_mask);
   if (BE (spot->alloc <= spot->num, 0))
     {
-      Idx new_alloc = 2 * spot->num + 2;
+      int new_alloc = 2 * spot->num + 2;
       re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,
 					      new_alloc);
       if (BE (new_array == NULL, 0))
@@ -1619,9 +1600,9 @@ free_state (re_dfastate_t *state)
 static re_dfastate_t *
 __attribute_warn_unused_result__
 create_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,
-		    re_hashval_t hash)
+		    unsigned int hash)
 {
-  Idx i;
+  int i;
   reg_errcode_t err;
   re_dfastate_t *newstate;
 
@@ -1669,9 +1650,9 @@ create_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,
 static re_dfastate_t *
 __attribute_warn_unused_result__
 create_cd_newstate (const re_dfa_t *dfa, const re_node_set *nodes,
-		    unsigned int context, re_hashval_t hash)
+		    unsigned int context, unsigned int hash)
 {
-  Idx i, nctx_nodes = 0;
+  int i, nctx_nodes = 0;
   reg_errcode_t err;
   re_dfastate_t *newstate;
 
diff --git a/posix/regex_internal.h b/posix/regex_internal.h
index 3b836ed206..41bf2d371c 100644
--- a/posix/regex_internal.h
+++ b/posix/regex_internal.h
@@ -15,7 +15,7 @@
 
    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
+   <http://www.gnu.org/licenses/>.  */
 
 #ifndef _REGEX_INTERNAL_H
 #define _REGEX_INTERNAL_H 1
@@ -26,78 +26,35 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include <langinfo.h>
-#include <locale.h>
-#include <wchar.h>
-#include <wctype.h>
-#include <stdbool.h>
-#include <stdint.h>
-
-/* Properties of integers.  Although Gnulib has intprops.h, glibc does
-   without for now.  */
-#ifndef _LIBC
-# include "intprops.h"
-#else
-/* True if the real type T is signed.  */
-# define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
-
-/* True if adding the nonnegative Idx values A and B would overflow.
-   If false, set *R to A + B.  A, B, and R may be evaluated more than
-   once, or zero times.  Although this is not a full implementation of
-   Gnulib INT_ADD_WRAPV, it is good enough for glibc regex code.
-   FIXME: This implementation is a fragile stopgap, and this file would
-   be simpler and more robust if intprops.h were migrated into glibc.  */
-# define INT_ADD_WRAPV(a, b, r) \
-   (IDX_MAX - (a) < (b) ? true : (*(r) = (a) + (b), false))
+#if defined HAVE_LANGINFO_H || defined HAVE_LANGINFO_CODESET || defined _LIBC
+# include <langinfo.h>
 #endif
-
-#ifdef _LIBC
+#if defined HAVE_LOCALE_H || defined _LIBC
+# include <locale.h>
+#endif
+#if defined HAVE_WCHAR_H || defined _LIBC
+# include <wchar.h>
+#endif /* HAVE_WCHAR_H || _LIBC */
+#if defined HAVE_WCTYPE_H || defined _LIBC
+# include <wctype.h>
+#endif /* HAVE_WCTYPE_H || _LIBC */
+#if defined HAVE_STDBOOL_H || defined _LIBC
+# include <stdbool.h>
+#endif /* HAVE_STDBOOL_H || _LIBC */
+#if defined HAVE_STDINT_H || defined _LIBC
+# include <stdint.h>
+#endif /* HAVE_STDINT_H || _LIBC */
+#if defined _LIBC
 # include <libc-lock.h>
-# define lock_define(name) __libc_lock_define (, name)
-# define lock_init(lock) (__libc_lock_init (lock), 0)
-# define lock_fini(lock) ((void) 0)
-# define lock_lock(lock) __libc_lock_lock (lock)
-# define lock_unlock(lock) __libc_lock_unlock (lock)
-#elif defined GNULIB_LOCK && !defined USE_UNLOCKED_IO
-# include "glthread/lock.h"
-  /* Use gl_lock_define if empty macro arguments are known to work.
-     Otherwise, fall back on less-portable substitutes.  */
-# if ((defined __GNUC__ && !defined __STRICT_ANSI__) \
-      || (defined __STDC_VERSION__ && 199901L <= __STDC_VERSION__))
-#  define lock_define(name) gl_lock_define (, name)
-# elif USE_POSIX_THREADS
-#  define lock_define(name) pthread_mutex_t name;
-# elif USE_PTH_THREADS
-#  define lock_define(name) pth_mutex_t name;
-# elif USE_SOLARIS_THREADS
-#  define lock_define(name) mutex_t name;
-# elif USE_WINDOWS_THREADS
-#  define lock_define(name) gl_lock_t name;
-# else
-#  define lock_define(name)
-# endif
-# define lock_init(lock) glthread_lock_init (&(lock))
-# define lock_fini(lock) glthread_lock_destroy (&(lock))
-# define lock_lock(lock) glthread_lock_lock (&(lock))
-# define lock_unlock(lock) glthread_lock_unlock (&(lock))
-#elif defined GNULIB_PTHREAD && !defined USE_UNLOCKED_IO
-# include <pthread.h>
-# define lock_define(name) pthread_mutex_t name;
-# define lock_init(lock) pthread_mutex_init (&(lock), 0)
-# define lock_fini(lock) pthread_mutex_destroy (&(lock))
-# define lock_lock(lock) pthread_mutex_lock (&(lock))
-# define lock_unlock(lock) pthread_mutex_unlock (&(lock))
 #else
-# define lock_define(name)
-# define lock_init(lock) 0
-# define lock_fini(lock) ((void) 0)
-  /* The 'dfa' avoids an "unused variable 'dfa'" warning from GCC.  */
-# define lock_lock(lock) ((void) dfa)
-# define lock_unlock(lock) ((void) 0)
+# define __libc_lock_define(CLASS,NAME)
+# define __libc_lock_init(NAME) do { } while (0)
+# define __libc_lock_lock(NAME) do { } while (0)
+# define __libc_lock_unlock(NAME) do { } while (0)
 #endif
 
 /* In case that the system doesn't have isblank().  */
-#if !defined _LIBC && ! (defined isblank || (HAVE_ISBLANK && HAVE_DECL_ISBLANK))
+#if !defined _LIBC && !defined HAVE_ISBLANK && !defined isblank
 # define isblank(ch) ((ch) == ' ' || (ch) == '\t')
 #endif
 
@@ -118,7 +75,6 @@
   __dcgettext (_libc_intl_domainname, msgid, LC_MESSAGES)
 # endif
 #else
-# undef gettext
 # define gettext(msgid) (msgid)
 #endif
 
@@ -128,17 +84,23 @@
 # define gettext_noop(String) String
 #endif
 
+/* For loser systems without the definition.  */
+#ifndef SIZE_MAX
+# define SIZE_MAX ((size_t) -1)
+#endif
+
 #if (defined MB_CUR_MAX && HAVE_WCTYPE_H && HAVE_ISWCTYPE) || _LIBC
 # define RE_ENABLE_I18N
 #endif
 
-#define BE(expr, val) __builtin_expect (expr, val)
+#if __GNUC__ >= 3
+# define BE(expr, val) __builtin_expect (expr, val)
+#else
+# define BE(expr, val) (expr)
+#endif
 
-/* Number of ASCII characters.  */
-#define ASCII_CHARS 0x80
-
-/* Number of single byte characters.  */
-#define SBC_MAX (UCHAR_MAX + 1)
+/* Number of single byte character.  */
+#define SBC_MAX 256
 
 #define COLL_ELEM_LEN_MAX 8
 
@@ -148,15 +110,11 @@
 
 /* Rename to standard API for using out of glibc.  */
 #ifndef _LIBC
-# undef __wctype
-# undef __iswctype
 # define __wctype wctype
-# define __iswalnum iswalnum
 # define __iswctype iswctype
-# define __towlower towlower
-# define __towupper towupper
 # define __btowc btowc
 # define __mbrtowc mbrtowc
+# define __mempcpy mempcpy
 # define __wcrtomb wcrtomb
 # define __regfree regfree
 # define attribute_hidden
@@ -166,70 +124,32 @@
 # define __attribute__(arg)
 #endif
 
-#ifndef SSIZE_MAX
-# define SSIZE_MAX ((ssize_t) (SIZE_MAX / 2))
-#endif
-
-/* The type of indexes into strings.  This is signed, not size_t,
-   since the API requires indexes to fit in regoff_t anyway, and using
-   signed integers makes the code a bit smaller and presumably faster.
-   The traditional GNU regex implementation uses int for indexes.
-   The POSIX-compatible implementation uses a possibly-wider type.
-   The name 'Idx' is three letters to minimize the hassle of
-   reindenting a lot of regex code that formerly used 'int'.  */
-typedef regoff_t Idx;
-#ifdef _REGEX_LARGE_OFFSETS
-# define IDX_MAX SSIZE_MAX
-#else
-# define IDX_MAX INT_MAX
-#endif
-
-/* A hash value, suitable for computing hash tables.  */
-typedef __re_size_t re_hashval_t;
+extern const char __re_error_msgid[] attribute_hidden;
+extern const size_t __re_error_msgid_idx[] attribute_hidden;
 
 /* An integer used to represent a set of bits.  It must be unsigned,
    and must be at least as wide as unsigned int.  */
 typedef unsigned long int bitset_word_t;
 /* All bits set in a bitset_word_t.  */
 #define BITSET_WORD_MAX ULONG_MAX
-
-/* Number of bits in a bitset_word_t.  For portability to hosts with
-   padding bits, do not use '(sizeof (bitset_word_t) * CHAR_BIT)';
-   instead, deduce it directly from BITSET_WORD_MAX.  Avoid
-   greater-than-32-bit integers and unconditional shifts by more than
-   31 bits, as they're not portable.  */
-#if BITSET_WORD_MAX == 0xffffffffUL
-# define BITSET_WORD_BITS 32
-#elif BITSET_WORD_MAX >> 31 >> 4 == 1
-# define BITSET_WORD_BITS 36
-#elif BITSET_WORD_MAX >> 31 >> 16 == 1
-# define BITSET_WORD_BITS 48
-#elif BITSET_WORD_MAX >> 31 >> 28 == 1
-# define BITSET_WORD_BITS 60
-#elif BITSET_WORD_MAX >> 31 >> 31 >> 1 == 1
-# define BITSET_WORD_BITS 64
-#elif BITSET_WORD_MAX >> 31 >> 31 >> 9 == 1
-# define BITSET_WORD_BITS 72
-#elif BITSET_WORD_MAX >> 31 >> 31 >> 31 >> 31 >> 3 == 1
-# define BITSET_WORD_BITS 128
-#elif BITSET_WORD_MAX >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 7 == 1
-# define BITSET_WORD_BITS 256
-#elif BITSET_WORD_MAX >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 31 >> 7 > 1
-# define BITSET_WORD_BITS 257 /* any value > SBC_MAX will do here */
-# if BITSET_WORD_BITS <= SBC_MAX
-#  error "Invalid SBC_MAX"
-# endif
-#else
-# error "Add case for new bitset_word_t size"
-#endif
-
-/* Number of bitset_word_t values in a bitset_t.  */
-#define BITSET_WORDS ((SBC_MAX + BITSET_WORD_BITS - 1) / BITSET_WORD_BITS)
-
+/* Number of bits in a bitset_word_t.  */
+#define BITSET_WORD_BITS (sizeof (bitset_word_t) * CHAR_BIT)
+/* Number of bitset_word_t in a bit_set.  */
+#define BITSET_WORDS (SBC_MAX / BITSET_WORD_BITS)
 typedef bitset_word_t bitset_t[BITSET_WORDS];
 typedef bitset_word_t *re_bitset_ptr_t;
 typedef const bitset_word_t *re_const_bitset_ptr_t;
 
+#define bitset_set(set,i) \
+  (set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 << i % BITSET_WORD_BITS)
+#define bitset_clear(set,i) \
+  (set[i / BITSET_WORD_BITS] &= ~((bitset_word_t) 1 << i % BITSET_WORD_BITS))
+#define bitset_contain(set,i) \
+  (set[i / BITSET_WORD_BITS] & ((bitset_word_t) 1 << i % BITSET_WORD_BITS))
+#define bitset_empty(set) memset (set, '\0', sizeof (bitset_t))
+#define bitset_set_all(set) memset (set, '\xff', sizeof (bitset_t))
+#define bitset_copy(dest,src) memcpy (dest, src, sizeof (bitset_t))
+
 #define PREV_WORD_CONSTRAINT 0x0001
 #define PREV_NOTWORD_CONSTRAINT 0x0002
 #define NEXT_WORD_CONSTRAINT 0x0004
@@ -257,9 +177,9 @@ typedef enum
 
 typedef struct
 {
-  Idx alloc;
-  Idx nelem;
-  Idx *elems;
+  int alloc;
+  int nelem;
+  int *elems;
 } re_node_set;
 
 typedef enum
@@ -345,19 +265,19 @@ typedef struct
   unsigned int non_match : 1;
 
   /* # of multibyte characters.  */
-  Idx nmbchars;
+  int nmbchars;
 
   /* # of collating symbols.  */
-  Idx ncoll_syms;
+  int ncoll_syms;
 
   /* # of equivalence classes. */
-  Idx nequiv_classes;
+  int nequiv_classes;
 
   /* # of range expressions. */
-  Idx nranges;
+  int nranges;
 
   /* # of character classes. */
-  Idx nchar_classes;
+  int nchar_classes;
 } re_charset_t;
 #endif /* RE_ENABLE_I18N */
 
@@ -370,10 +290,10 @@ typedef struct
 #ifdef RE_ENABLE_I18N
     re_charset_t *mbcset;	/* for COMPLEX_BRACKET */
 #endif /* RE_ENABLE_I18N */
-    Idx idx;			/* for BACK_REF */
+    int idx;			/* for BACK_REF */
     re_context_type ctx_type;	/* for ANCHOR */
   } opr;
-#if __GNUC__ >= 2 && !defined __STRICT_ANSI__
+#if __GNUC__ >= 2
   re_token_type_t type : 8;
 #else
   re_token_type_t type;
@@ -404,30 +324,30 @@ struct re_string_t
 #ifdef RE_ENABLE_I18N
   /* Store the wide character string which is corresponding to MBS.  */
   wint_t *wcs;
-  Idx *offsets;
+  int *offsets;
   mbstate_t cur_state;
 #endif
   /* Index in RAW_MBS.  Each character mbs[i] corresponds to
      raw_mbs[raw_mbs_idx + i].  */
-  Idx raw_mbs_idx;
+  int raw_mbs_idx;
   /* The length of the valid characters in the buffers.  */
-  Idx valid_len;
+  int valid_len;
   /* The corresponding number of bytes in raw_mbs array.  */
-  Idx valid_raw_len;
+  int valid_raw_len;
   /* The length of the buffers MBS and WCS.  */
-  Idx bufs_len;
+  int bufs_len;
   /* The index in MBS, which is updated by re_string_fetch_byte.  */
-  Idx cur_idx;
+  int cur_idx;
   /* length of RAW_MBS array.  */
-  Idx raw_len;
+  int raw_len;
   /* This is RAW_LEN - RAW_MBS_IDX + VALID_LEN - VALID_RAW_LEN.  */
-  Idx len;
+  int len;
   /* End of the buffer may be shorter than its length in the cases such
      as re_match_2, re_search_2.  Then, we use STOP for end of the buffer
      instead of LEN.  */
-  Idx raw_stop;
+  int raw_stop;
   /* This is RAW_STOP - RAW_MBS_IDX adjusted through OFFSETS.  */
-  Idx stop;
+  int stop;
 
   /* The context of mbs[0].  We store the context independently, since
      the context of mbs[0] may be different from raw_mbs[0], which is
@@ -437,7 +357,7 @@ struct re_string_t
   RE_TRANSLATE_TYPE trans;
   /* Copy of re_dfa_t's word_char.  */
   re_const_bitset_ptr_t word_char;
-  /* true if REG_ICASE.  */
+  /* 1 if REG_ICASE.  */
   unsigned char icase;
   unsigned char is_utf8;
   unsigned char map_notascii;
@@ -453,10 +373,18 @@ typedef struct re_string_t re_string_t;
 struct re_dfa_t;
 typedef struct re_dfa_t re_dfa_t;
 
-#ifndef _LIBC
-# define IS_IN(libc) false
+#if IS_IN (libc)
+static reg_errcode_t re_string_realloc_buffers (re_string_t *pstr,
+						int new_buf_len);
+# ifdef RE_ENABLE_I18N
+static void build_wcs_buffer (re_string_t *pstr);
+static reg_errcode_t build_wcs_upper_buffer (re_string_t *pstr);
+# endif /* RE_ENABLE_I18N */
+static void build_upper_buffer (re_string_t *pstr);
+static void re_string_translate_buffer (re_string_t *pstr);
+static unsigned int re_string_context_at (const re_string_t *input, int idx,
+					  int eflags) __attribute__ ((pure));
 #endif
-
 #define re_string_peek_byte(pstr, offset) \
   ((pstr)->mbs[(pstr)->cur_idx + offset])
 #define re_string_fetch_byte(pstr) \
@@ -474,9 +402,7 @@ typedef struct re_dfa_t re_dfa_t;
 #define re_string_skip_bytes(pstr,idx) ((pstr)->cur_idx += (idx))
 #define re_string_set_index(pstr,idx) ((pstr)->cur_idx = (idx))
 
-#if defined _LIBC || HAVE_ALLOCA
-# include <alloca.h>
-#endif
+#include <alloca.h>
 
 #ifndef _LIBC
 # if HAVE_ALLOCA
@@ -488,24 +414,9 @@ typedef struct re_dfa_t re_dfa_t;
 # else
 /* alloca is implemented with malloc, so just use malloc.  */
 #  define __libc_use_alloca(n) 0
-#  undef alloca
-#  define alloca(n) malloc (n)
 # endif
 #endif
 
-#ifdef _LIBC
-# define MALLOC_0_IS_NONNULL 1
-#elif !defined MALLOC_0_IS_NONNULL
-# define MALLOC_0_IS_NONNULL 0
-#endif
-
-#ifndef MAX
-# define MAX(a,b) ((a) < (b) ? (b) : (a))
-#endif
-#ifndef MIN
-# define MIN(a,b) ((a) < (b) ? (a) : (b))
-#endif
-
 #define re_malloc(t,n) ((t *) malloc ((n) * sizeof (t)))
 #define re_realloc(p,t,n) ((t *) realloc (p, (n) * sizeof (t)))
 #define re_free(p) free (p)
@@ -520,9 +431,9 @@ struct bin_tree_t
 
   re_token_t token;
 
-  /* 'node_idx' is the index in dfa->nodes, if 'type' == 0.
-     Otherwise 'type' indicate the type of this node.  */
-  Idx node_idx;
+  /* `node_idx' is the index in dfa->nodes, if `type' == 0.
+     Otherwise `type' indicate the type of this node.  */
+  int node_idx;
 };
 typedef struct bin_tree_t bin_tree_t;
 
@@ -566,7 +477,7 @@ typedef struct bin_tree_storage_t bin_tree_storage_t;
 
 struct re_dfastate_t
 {
-  re_hashval_t hash;
+  unsigned int hash;
   re_node_set nodes;
   re_node_set non_eps_nodes;
   re_node_set inveclosure;
@@ -574,9 +485,9 @@ struct re_dfastate_t
   struct re_dfastate_t **trtable, **word_trtable;
   unsigned int context : 4;
   unsigned int halt : 1;
-  /* If this state can accept "multi byte".
+  /* If this state can accept `multi byte'.
      Note that we refer to multibyte characters, and multi character
-     collating elements as "multi byte".  */
+     collating elements as `multi byte'.  */
   unsigned int accept_mb : 1;
   /* If this state has backreference node(s).  */
   unsigned int has_backref : 1;
@@ -586,8 +497,8 @@ typedef struct re_dfastate_t re_dfastate_t;
 
 struct re_state_table_entry
 {
-  Idx num;
-  Idx alloc;
+  int num;
+  int alloc;
   re_dfastate_t **array;
 };
 
@@ -595,8 +506,8 @@ struct re_state_table_entry
 
 typedef struct
 {
-  Idx next_idx;
-  Idx alloc;
+  int next_idx;
+  int alloc;
   re_dfastate_t **array;
 } state_array_t;
 
@@ -604,8 +515,8 @@ typedef struct
 
 typedef struct
 {
-  Idx node;
-  Idx str_idx; /* The position NODE match at.  */
+  int node;
+  int str_idx; /* The position NODE match at.  */
   state_array_t path;
 } re_sub_match_last_t;
 
@@ -615,20 +526,20 @@ typedef struct
 
 typedef struct
 {
-  Idx str_idx;
-  Idx node;
+  int str_idx;
+  int node;
   state_array_t *path;
-  Idx alasts; /* Allocation size of LASTS.  */
-  Idx nlasts; /* The number of LASTS.  */
+  int alasts; /* Allocation size of LASTS.  */
+  int nlasts; /* The number of LASTS.  */
   re_sub_match_last_t **lasts;
 } re_sub_match_top_t;
 
 struct re_backref_cache_entry
 {
-  Idx node;
-  Idx str_idx;
-  Idx subexp_from;
-  Idx subexp_to;
+  int node;
+  int str_idx;
+  int subexp_from;
+  int subexp_to;
   char more;
   char unused;
   unsigned short int eps_reachable_subexps_map;
@@ -646,18 +557,18 @@ typedef struct
   /* EFLAGS of the argument of regexec.  */
   int eflags;
   /* Where the matching ends.  */
-  Idx match_last;
-  Idx last_node;
+  int match_last;
+  int last_node;
   /* The state log used by the matcher.  */
   re_dfastate_t **state_log;
-  Idx state_log_top;
+  int state_log_top;
   /* Back reference cache.  */
-  Idx nbkref_ents;
-  Idx abkref_ents;
+  int nbkref_ents;
+  int abkref_ents;
   struct re_backref_cache_entry *bkref_ents;
   int max_mb_elem_len;
-  Idx nsub_tops;
-  Idx asub_tops;
+  int nsub_tops;
+  int asub_tops;
   re_sub_match_top_t **sub_tops;
 } re_match_context_t;
 
@@ -665,23 +576,23 @@ typedef struct
 {
   re_dfastate_t **sifted_states;
   re_dfastate_t **limited_states;
-  Idx last_node;
-  Idx last_str_idx;
+  int last_node;
+  int last_str_idx;
   re_node_set limits;
 } re_sift_context_t;
 
 struct re_fail_stack_ent_t
 {
-  Idx idx;
-  Idx node;
+  int idx;
+  int node;
   regmatch_t *regs;
   re_node_set eps_via_nodes;
 };
 
 struct re_fail_stack_t
 {
-  Idx num;
-  Idx alloc;
+  int num;
+  int alloc;
   struct re_fail_stack_ent_t *stack;
 };
 
@@ -690,8 +601,8 @@ struct re_dfa_t
   re_token_t *nodes;
   size_t nodes_alloc;
   size_t nodes_len;
-  Idx *nexts;
-  Idx *org_indices;
+  int *nexts;
+  int *org_indices;
   re_node_set *edests;
   re_node_set *eclosures;
   re_node_set *inveclosures;
@@ -705,10 +616,10 @@ struct re_dfa_t
   re_bitset_ptr_t sb_char;
   int str_tree_storage_idx;
 
-  /* number of subexpressions 're_nsub' is in regex_t.  */
-  re_hashval_t state_hash_mask;
-  Idx init_node;
-  Idx nbackref; /* The number of backreference in this dfa.  */
+  /* number of subexpressions `re_nsub' is in regex_t.  */
+  unsigned int state_hash_mask;
+  int init_node;
+  int nbackref; /* The number of backreference in this dfa.  */
 
   /* Bitmap expressing which backreference is used.  */
   bitset_word_t used_bkref_map;
@@ -725,11 +636,11 @@ struct re_dfa_t
   int mb_cur_max;
   bitset_t word_char;
   reg_syntax_t syntax;
-  Idx *subexp_map;
+  int *subexp_map;
 #ifdef DEBUG
   char* re_str;
 #endif
-  lock_define (lock)
+  __libc_lock_define (, lock)
 };
 
 #define re_node_set_init_empty(set) memset (set, '\0', sizeof (re_node_set))
@@ -760,60 +671,16 @@ typedef struct
 } bracket_elem_t;
 
 
-/* Functions for bitset_t operation.  */
-
-static inline void
-bitset_set (bitset_t set, Idx i)
-{
-  set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 << i % BITSET_WORD_BITS;
-}
-
-static inline void
-bitset_clear (bitset_t set, Idx i)
-{
-  set[i / BITSET_WORD_BITS] &= ~ ((bitset_word_t) 1 << i % BITSET_WORD_BITS);
-}
-
-static inline bool
-bitset_contain (const bitset_t set, Idx i)
-{
-  return (set[i / BITSET_WORD_BITS] >> i % BITSET_WORD_BITS) & 1;
-}
-
-static inline void
-bitset_empty (bitset_t set)
-{
-  memset (set, '\0', sizeof (bitset_t));
-}
-
-static inline void
-bitset_set_all (bitset_t set)
-{
-  memset (set, -1, sizeof (bitset_word_t) * (SBC_MAX / BITSET_WORD_BITS));
-  if (SBC_MAX % BITSET_WORD_BITS != 0)
-    set[BITSET_WORDS - 1] =
-      ((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1;
-}
-
-static inline void
-bitset_copy (bitset_t dest, const bitset_t src)
-{
-  memcpy (dest, src, sizeof (bitset_t));
-}
-
-static inline void
+/* Inline functions for bitset operation.  */
+static void __attribute__ ((unused))
 bitset_not (bitset_t set)
 {
   int bitset_i;
-  for (bitset_i = 0; bitset_i < SBC_MAX / BITSET_WORD_BITS; ++bitset_i)
+  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)
     set[bitset_i] = ~set[bitset_i];
-  if (SBC_MAX % BITSET_WORD_BITS != 0)
-    set[BITSET_WORDS - 1] =
-      ((((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1)
-       & ~set[BITSET_WORDS - 1]);
 }
 
-static inline void
+static void __attribute__ ((unused))
 bitset_merge (bitset_t dest, const bitset_t src)
 {
   int bitset_i;
@@ -821,7 +688,7 @@ bitset_merge (bitset_t dest, const bitset_t src)
     dest[bitset_i] |= src[bitset_i];
 }
 
-static inline void
+static void __attribute__ ((unused))
 bitset_mask (bitset_t dest, const bitset_t src)
 {
   int bitset_i;
@@ -830,10 +697,10 @@ bitset_mask (bitset_t dest, const bitset_t src)
 }
 
 #ifdef RE_ENABLE_I18N
-/* Functions for re_string.  */
+/* Inline functions for re_string.  */
 static int
 __attribute__ ((pure, unused))
-re_string_char_size_at (const re_string_t *pstr, Idx idx)
+re_string_char_size_at (const re_string_t *pstr, int idx)
 {
   int byte_idx;
   if (pstr->mb_cur_max == 1)
@@ -846,22 +713,23 @@ re_string_char_size_at (const re_string_t *pstr, Idx idx)
 
 static wint_t
 __attribute__ ((pure, unused))
-re_string_wchar_at (const re_string_t *pstr, Idx idx)
+re_string_wchar_at (const re_string_t *pstr, int idx)
 {
   if (pstr->mb_cur_max == 1)
     return (wint_t) pstr->mbs[idx];
   return (wint_t) pstr->wcs[idx];
 }
 
-# ifdef _LIBC
-#  include <locale/weight.h>
-# endif
+# if IS_IN (libc)
+#  ifdef _LIBC
+#   include <locale/weight.h>
+#  endif
 
 static int
 __attribute__ ((pure, unused))
-re_string_elem_size_at (const re_string_t *pstr, Idx idx)
+re_string_elem_size_at (const re_string_t *pstr, int idx)
 {
-# ifdef _LIBC
+#  ifdef _LIBC
   const unsigned char *p, *extra;
   const int32_t *table, *indirect;
   uint_fast32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
@@ -878,34 +746,10 @@ re_string_elem_size_at (const re_string_t *pstr, Idx idx)
       return p - pstr->mbs - idx;
     }
   else
-# endif /* _LIBC */
+#  endif /* _LIBC */
     return 1;
 }
+# endif
 #endif /* RE_ENABLE_I18N */
 
-#ifndef __GNUC_PREREQ
-# if defined __GNUC__ && defined __GNUC_MINOR__
-#  define __GNUC_PREREQ(maj, min) \
-         ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
-# else
-#  define __GNUC_PREREQ(maj, min) 0
-# endif
-#endif
-
-#if __GNUC_PREREQ (3,4)
-# undef __attribute_warn_unused_result__
-# define __attribute_warn_unused_result__ \
-   __attribute__ ((__warn_unused_result__))
-#else
-# define __attribute_warn_unused_result__ /* empty */
-#endif
-
-#ifndef FALLTHROUGH
-# if __GNUC__ < 7
-#  define FALLTHROUGH ((void) 0)
-# else
-#  define FALLTHROUGH __attribute__ ((__fallthrough__))
-# endif
-#endif
-
 #endif /*  _REGEX_INTERNAL_H */
diff --git a/posix/regexec.c b/posix/regexec.c
index 9edd9fb394..4b1ab4ecff 100644
--- a/posix/regexec.c
+++ b/posix/regexec.c
@@ -15,98 +15,100 @@
 
    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdint.h>
 
 static reg_errcode_t match_ctx_init (re_match_context_t *cache, int eflags,
-				     Idx n);
+				     int n);
 static void match_ctx_clean (re_match_context_t *mctx);
 static void match_ctx_free (re_match_context_t *cache);
-static reg_errcode_t match_ctx_add_entry (re_match_context_t *cache, Idx node,
-					  Idx str_idx, Idx from, Idx to);
-static Idx search_cur_bkref_entry (const re_match_context_t *mctx, Idx str_idx);
-static reg_errcode_t match_ctx_add_subtop (re_match_context_t *mctx, Idx node,
-					   Idx str_idx);
+static reg_errcode_t match_ctx_add_entry (re_match_context_t *cache, int node,
+					  int str_idx, int from, int to);
+static int search_cur_bkref_entry (const re_match_context_t *mctx,
+				   int str_idx);
+static reg_errcode_t match_ctx_add_subtop (re_match_context_t *mctx, int node,
+					   int str_idx);
 static re_sub_match_last_t * match_ctx_add_sublast (re_sub_match_top_t *subtop,
-						    Idx node, Idx str_idx);
+						   int node, int str_idx);
 static void sift_ctx_init (re_sift_context_t *sctx, re_dfastate_t **sifted_sts,
-			   re_dfastate_t **limited_sts, Idx last_node,
-			   Idx last_str_idx);
+			   re_dfastate_t **limited_sts, int last_node,
+			   int last_str_idx);
 static reg_errcode_t re_search_internal (const regex_t *preg,
-					 const char *string, Idx length,
-					 Idx start, Idx last_start, Idx stop,
+					 const char *string, int length,
+					 int start, int range, int stop,
 					 size_t nmatch, regmatch_t pmatch[],
 					 int eflags);
-static regoff_t re_search_2_stub (struct re_pattern_buffer *bufp,
-				  const char *string1, Idx length1,
-				  const char *string2, Idx length2,
-				  Idx start, regoff_t range,
-				  struct re_registers *regs,
-				  Idx stop, bool ret_len);
-static regoff_t re_search_stub (struct re_pattern_buffer *bufp,
-				const char *string, Idx length, Idx start,
-				regoff_t range, Idx stop,
-				struct re_registers *regs,
-				bool ret_len);
+static int re_search_2_stub (struct re_pattern_buffer *bufp,
+			     const char *string1, int length1,
+			     const char *string2, int length2,
+			     int start, int range, struct re_registers *regs,
+			     int stop, int ret_len);
+static int re_search_stub (struct re_pattern_buffer *bufp,
+			   const char *string, int length, int start,
+			   int range, int stop, struct re_registers *regs,
+			   int ret_len);
 static unsigned re_copy_regs (struct re_registers *regs, regmatch_t *pmatch,
-                              Idx nregs, int regs_allocated);
+			      int nregs, int regs_allocated);
 static reg_errcode_t prune_impossible_nodes (re_match_context_t *mctx);
-static Idx check_matching (re_match_context_t *mctx, bool fl_longest_match,
-			   Idx *p_match_first);
-static Idx check_halt_state_context (const re_match_context_t *mctx,
-				     const re_dfastate_t *state, Idx idx);
+static int check_matching (re_match_context_t *mctx, int fl_longest_match,
+			   int *p_match_first);
+static int check_halt_state_context (const re_match_context_t *mctx,
+				     const re_dfastate_t *state, int idx);
 static void update_regs (const re_dfa_t *dfa, regmatch_t *pmatch,
-			 regmatch_t *prev_idx_match, Idx cur_node,
-			 Idx cur_idx, Idx nmatch);
+			 regmatch_t *prev_idx_match, int cur_node,
+			 int cur_idx, int nmatch);
 static reg_errcode_t push_fail_stack (struct re_fail_stack_t *fs,
-				      Idx str_idx, Idx dest_node, Idx nregs,
+				      int str_idx, int dest_node, int nregs,
 				      regmatch_t *regs,
 				      re_node_set *eps_via_nodes);
 static reg_errcode_t set_regs (const regex_t *preg,
 			       const re_match_context_t *mctx,
 			       size_t nmatch, regmatch_t *pmatch,
-			       bool fl_backtrack);
+			       int fl_backtrack);
 static reg_errcode_t free_fail_stack_return (struct re_fail_stack_t *fs);
 
 #ifdef RE_ENABLE_I18N
 static int sift_states_iter_mb (const re_match_context_t *mctx,
 				re_sift_context_t *sctx,
-				Idx node_idx, Idx str_idx, Idx max_str_idx);
+				int node_idx, int str_idx, int max_str_idx);
 #endif /* RE_ENABLE_I18N */
 static reg_errcode_t sift_states_backward (const re_match_context_t *mctx,
 					   re_sift_context_t *sctx);
 static reg_errcode_t build_sifted_states (const re_match_context_t *mctx,
-					  re_sift_context_t *sctx, Idx str_idx,
+					  re_sift_context_t *sctx, int str_idx,
 					  re_node_set *cur_dest);
 static reg_errcode_t update_cur_sifted_state (const re_match_context_t *mctx,
 					      re_sift_context_t *sctx,
-					      Idx str_idx,
+					      int str_idx,
 					      re_node_set *dest_nodes);
 static reg_errcode_t add_epsilon_src_nodes (const re_dfa_t *dfa,
 					    re_node_set *dest_nodes,
 					    const re_node_set *candidates);
-static bool check_dst_limits (const re_match_context_t *mctx,
-			      const re_node_set *limits,
-			      Idx dst_node, Idx dst_idx, Idx src_node,
-			      Idx src_idx);
+static int check_dst_limits (const re_match_context_t *mctx,
+			     re_node_set *limits,
+			     int dst_node, int dst_idx, int src_node,
+			     int src_idx);
 static int check_dst_limits_calc_pos_1 (const re_match_context_t *mctx,
-					int boundaries, Idx subexp_idx,
-					Idx from_node, Idx bkref_idx);
+					int boundaries, int subexp_idx,
+					int from_node, int bkref_idx);
 static int check_dst_limits_calc_pos (const re_match_context_t *mctx,
-				      Idx limit, Idx subexp_idx,
-				      Idx node, Idx str_idx,
-				      Idx bkref_idx);
+				      int limit, int subexp_idx,
+				      int node, int str_idx,
+				      int bkref_idx);
 static reg_errcode_t check_subexp_limits (const re_dfa_t *dfa,
 					  re_node_set *dest_nodes,
 					  const re_node_set *candidates,
 					  re_node_set *limits,
 					  struct re_backref_cache_entry *bkref_ents,
-					  Idx str_idx);
+					  int str_idx);
 static reg_errcode_t sift_states_bkref (const re_match_context_t *mctx,
 					re_sift_context_t *sctx,
-					Idx str_idx, const re_node_set *candidates);
+					int str_idx,
+					const re_node_set *candidates);
 static reg_errcode_t merge_state_array (const re_dfa_t *dfa,
 					re_dfastate_t **dst,
-					re_dfastate_t **src, Idx num);
+					re_dfastate_t **src, int num);
 static re_dfastate_t *find_recover_state (reg_errcode_t *err,
 					 re_match_context_t *mctx);
 static re_dfastate_t *transit_state (reg_errcode_t *err,
@@ -117,7 +119,7 @@ static re_dfastate_t *merge_state_with_log (reg_errcode_t *err,
 					    re_dfastate_t *next_state);
 static reg_errcode_t check_subexp_matching_top (re_match_context_t *mctx,
 						re_node_set *cur_nodes,
-						Idx str_idx);
+						int str_idx);
 #if 0
 static re_dfastate_t *transit_state_sb (reg_errcode_t *err,
 					re_match_context_t *mctx,
@@ -130,46 +132,46 @@ static reg_errcode_t transit_state_mb (re_match_context_t *mctx,
 static reg_errcode_t transit_state_bkref (re_match_context_t *mctx,
 					  const re_node_set *nodes);
 static reg_errcode_t get_subexp (re_match_context_t *mctx,
-				 Idx bkref_node, Idx bkref_str_idx);
+				 int bkref_node, int bkref_str_idx);
 static reg_errcode_t get_subexp_sub (re_match_context_t *mctx,
 				     const re_sub_match_top_t *sub_top,
 				     re_sub_match_last_t *sub_last,
-				     Idx bkref_node, Idx bkref_str);
-static Idx find_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,
-			     Idx subexp_idx, int type);
+				     int bkref_node, int bkref_str);
+static int find_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,
+			     int subexp_idx, int type);
 static reg_errcode_t check_arrival (re_match_context_t *mctx,
-				    state_array_t *path, Idx top_node,
-				    Idx top_str, Idx last_node, Idx last_str,
+				    state_array_t *path, int top_node,
+				    int top_str, int last_node, int last_str,
 				    int type);
 static reg_errcode_t check_arrival_add_next_nodes (re_match_context_t *mctx,
-						   Idx str_idx,
+						   int str_idx,
 						   re_node_set *cur_nodes,
 						   re_node_set *next_nodes);
 static reg_errcode_t check_arrival_expand_ecl (const re_dfa_t *dfa,
 					       re_node_set *cur_nodes,
-					       Idx ex_subexp, int type);
+					       int ex_subexp, int type);
 static reg_errcode_t check_arrival_expand_ecl_sub (const re_dfa_t *dfa,
 						   re_node_set *dst_nodes,
-						   Idx target, Idx ex_subexp,
+						   int target, int ex_subexp,
 						   int type);
 static reg_errcode_t expand_bkref_cache (re_match_context_t *mctx,
-					 re_node_set *cur_nodes, Idx cur_str,
-					 Idx subexp_num, int type);
-static bool build_trtable (const re_dfa_t *dfa, re_dfastate_t *state);
+					 re_node_set *cur_nodes, int cur_str,
+					 int subexp_num, int type);
+static int build_trtable (const re_dfa_t *dfa, re_dfastate_t *state);
 #ifdef RE_ENABLE_I18N
-static int check_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,
-				    const re_string_t *input, Idx idx);
+static int check_node_accept_bytes (const re_dfa_t *dfa, int node_idx,
+				    const re_string_t *input, int idx);
 # ifdef _LIBC
 static unsigned int find_collation_sequence_value (const unsigned char *mbs,
 						   size_t name_len);
 # endif /* _LIBC */
 #endif /* RE_ENABLE_I18N */
-static Idx group_nodes_into_DFAstates (const re_dfa_t *dfa,
+static int group_nodes_into_DFAstates (const re_dfa_t *dfa,
 				       const re_dfastate_t *state,
 				       re_node_set *states_node,
 				       bitset_t *states_ch);
-static bool check_node_accept (const re_match_context_t *mctx,
-			       const re_token_t *node, Idx idx);
+static int check_node_accept (const re_match_context_t *mctx,
+			      const re_token_t *node, int idx);
 static reg_errcode_t extend_buffers (re_match_context_t *mctx, int min_len);
 
 /* Entry point for POSIX code.  */
@@ -178,23 +180,23 @@ static reg_errcode_t extend_buffers (re_match_context_t *mctx, int min_len);
    string STRING.
 
    If NMATCH is zero or REG_NOSUB was set in the cflags argument to
-   'regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
+   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
    least NMATCH elements, and we set them to the offsets of the
    corresponding matched substrings.
 
-   EFLAGS specifies "execution flags" which affect matching: if
+   EFLAGS specifies `execution flags' which affect matching: if
    REG_NOTBOL is set, then ^ does not match at the beginning of the
    string; if REG_NOTEOL is set, then $ does not match at the end.
 
    We return 0 if we find a match and REG_NOMATCH if not.  */
 
 int
-regexec (const regex_t *_Restrict_ preg, const char *_Restrict_ string,
+regexec (const regex_t *__restrict preg, const char *__restrict string,
 	 size_t nmatch, regmatch_t pmatch[], int eflags)
 {
   reg_errcode_t err;
-  Idx start, length;
-  re_dfa_t *dfa = preg->buffer;
+  int start, length;
+  re_dfa_t *dfa = (re_dfa_t *) preg->buffer;
 
   if (eflags & ~(REG_NOTBOL | REG_NOTEOL | REG_STARTEND))
     return REG_BADPAT;
@@ -210,14 +212,14 @@ regexec (const regex_t *_Restrict_ preg, const char *_Restrict_ string,
       length = strlen (string);
     }
 
-  lock_lock (dfa->lock);
+  __libc_lock_lock (dfa->lock);
   if (preg->no_sub)
-    err = re_search_internal (preg, string, length, start, length,
+    err = re_search_internal (preg, string, length, start, length - start,
 			      length, 0, NULL, eflags);
   else
-    err = re_search_internal (preg, string, length, start, length,
+    err = re_search_internal (preg, string, length, start, length - start,
 			      length, nmatch, pmatch, eflags);
-  lock_unlock (dfa->lock);
+  __libc_lock_unlock (dfa->lock);
   return err != REG_NOERROR;
 }
 
@@ -232,8 +234,8 @@ __typeof__ (__regexec) __compat_regexec;
 
 int
 attribute_compat_text_section
-__compat_regexec (const regex_t *_Restrict_ preg,
-		  const char *_Restrict_ string, size_t nmatch,
+__compat_regexec (const regex_t *__restrict preg,
+		  const char *__restrict string, size_t nmatch,
 		  regmatch_t pmatch[], int eflags)
 {
   return regexec (preg, string, nmatch, pmatch,
@@ -272,65 +274,62 @@ compat_symbol (libc, __compat_regexec, regexec, GLIBC_2_0);
    return the position of the start of the match.  Return value -1 means no
    match was found and -2 indicates an internal error.  */
 
-regoff_t
-re_match (struct re_pattern_buffer *bufp, const char *string, Idx length,
-	  Idx start, struct re_registers *regs)
+int
+re_match (struct re_pattern_buffer *bufp, const char *string, int length,
+	  int start, struct re_registers *regs)
 {
-  return re_search_stub (bufp, string, length, start, 0, length, regs, true);
+  return re_search_stub (bufp, string, length, start, 0, length, regs, 1);
 }
 #ifdef _LIBC
 weak_alias (__re_match, re_match)
 #endif
 
-regoff_t
-re_search (struct re_pattern_buffer *bufp, const char *string, Idx length,
-	   Idx start, regoff_t range, struct re_registers *regs)
+int
+re_search (struct re_pattern_buffer *bufp, const char *string, int length,
+	   int start, int range, struct re_registers *regs)
 {
-  return re_search_stub (bufp, string, length, start, range, length, regs,
-			 false);
+  return re_search_stub (bufp, string, length, start, range, length, regs, 0);
 }
 #ifdef _LIBC
 weak_alias (__re_search, re_search)
 #endif
 
-regoff_t
-re_match_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,
-	    const char *string2, Idx length2, Idx start,
-	    struct re_registers *regs, Idx stop)
+int
+re_match_2 (struct re_pattern_buffer *bufp, const char *string1, int length1,
+	    const char *string2, int length2, int start,
+	    struct re_registers *regs, int stop)
 {
   return re_search_2_stub (bufp, string1, length1, string2, length2,
-			   start, 0, regs, stop, true);
+			   start, 0, regs, stop, 1);
 }
 #ifdef _LIBC
 weak_alias (__re_match_2, re_match_2)
 #endif
 
-regoff_t
-re_search_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,
-	     const char *string2, Idx length2, Idx start, regoff_t range,
-	     struct re_registers *regs, Idx stop)
+int
+re_search_2 (struct re_pattern_buffer *bufp, const char *string1, int length1,
+	     const char *string2, int length2, int start, int range,
+	     struct re_registers *regs, int stop)
 {
   return re_search_2_stub (bufp, string1, length1, string2, length2,
-			   start, range, regs, stop, false);
+			   start, range, regs, stop, 0);
 }
 #ifdef _LIBC
 weak_alias (__re_search_2, re_search_2)
 #endif
 
-static regoff_t
+static int
 re_search_2_stub (struct re_pattern_buffer *bufp, const char *string1,
-		  Idx length1, const char *string2, Idx length2, Idx start,
-		  regoff_t range, struct re_registers *regs,
-		  Idx stop, bool ret_len)
+		  int length1, const char *string2, int length2, int start,
+		  int range, struct re_registers *regs,
+		  int stop, int ret_len)
 {
   const char *str;
-  regoff_t rval;
-  Idx len;
+  int rval;
+  int len = length1 + length2;
   char *s = NULL;
 
-  if (BE ((length1 < 0 || length2 < 0 || stop < 0
-           || INT_ADD_WRAPV (length1, length2, &len)),
-          0))
+  if (BE (length1 < 0 || length2 < 0 || stop < 0 || len < length1, 0))
     return -2;
 
   /* Concatenate the strings.  */
@@ -354,45 +353,42 @@ re_search_2_stub (struct re_pattern_buffer *bufp, const char *string1,
   else
     str = string1;
 
-  rval = re_search_stub (bufp, str, len, start, range, stop, regs,
-			 ret_len);
+  rval = re_search_stub (bufp, str, len, start, range, stop, regs, ret_len);
   re_free (s);
   return rval;
 }
 
 /* The parameters have the same meaning as those of re_search.
    Additional parameters:
-   If RET_LEN is true the length of the match is returned (re_match style);
+   If RET_LEN is nonzero the length of the match is returned (re_match style);
    otherwise the position of the match is returned.  */
 
-static regoff_t
-re_search_stub (struct re_pattern_buffer *bufp, const char *string, Idx length,
-		Idx start, regoff_t range, Idx stop, struct re_registers *regs,
-		bool ret_len)
+static int
+re_search_stub (struct re_pattern_buffer *bufp, const char *string, int length,
+		int start, int range, int stop, struct re_registers *regs,
+		int ret_len)
 {
   reg_errcode_t result;
   regmatch_t *pmatch;
-  Idx nregs;
-  regoff_t rval;
+  int nregs, rval;
   int eflags = 0;
-  re_dfa_t *dfa = bufp->buffer;
-  Idx last_start = start + range;
+  re_dfa_t *dfa = (re_dfa_t *) bufp->buffer;
 
   /* Check for out-of-range.  */
   if (BE (start < 0 || start > length, 0))
     return -1;
-  if (BE (length < last_start || (0 <= range && last_start < start), 0))
-    last_start = length;
-  else if (BE (last_start < 0 || (range < 0 && start <= last_start), 0))
-    last_start = 0;
+  if (BE (start + range > length, 0))
+    range = length - start;
+  else if (BE (start + range < 0, 0))
+    range = -start;
 
-  lock_lock (dfa->lock);
+  __libc_lock_lock (dfa->lock);
 
   eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;
   eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;
 
   /* Compile fastmap if we haven't yet.  */
-  if (start < last_start && bufp->fastmap != NULL && !bufp->fastmap_accurate)
+  if (range > 0 && bufp->fastmap != NULL && !bufp->fastmap_accurate)
     re_compile_fastmap (bufp);
 
   if (BE (bufp->no_sub, 0))
@@ -401,8 +397,8 @@ re_search_stub (struct re_pattern_buffer *bufp, const char *string, Idx length,
   /* We need at least 1 register.  */
   if (regs == NULL)
     nregs = 1;
-  else if (BE (bufp->regs_allocated == REGS_FIXED
-	       && regs->num_regs <= bufp->re_nsub, 0))
+  else if (BE (bufp->regs_allocated == REGS_FIXED &&
+	       regs->num_regs < bufp->re_nsub + 1, 0))
     {
       nregs = regs->num_regs;
       if (BE (nregs < 1, 0))
@@ -421,14 +417,14 @@ re_search_stub (struct re_pattern_buffer *bufp, const char *string, Idx length,
       goto out;
     }
 
-  result = re_search_internal (bufp, string, length, start, last_start, stop,
+  result = re_search_internal (bufp, string, length, start, range, stop,
 			       nregs, pmatch, eflags);
 
   rval = 0;
 
-  /* I hope we needn't fill their regs with -1's when no match was found.  */
+  /* I hope we needn't fill ther regs with -1's when no match was found.  */
   if (result != REG_NOERROR)
-    rval = result == REG_NOMATCH ? -1 : -2;
+    rval = -1;
   else if (regs != NULL)
     {
       /* If caller wants register contents data back, copy them.  */
@@ -450,18 +446,18 @@ re_search_stub (struct re_pattern_buffer *bufp, const char *string, Idx length,
     }
   re_free (pmatch);
  out:
-  lock_unlock (dfa->lock);
+  __libc_lock_unlock (dfa->lock);
   return rval;
 }
 
 static unsigned
-re_copy_regs (struct re_registers *regs, regmatch_t *pmatch, Idx nregs,
+re_copy_regs (struct re_registers *regs, regmatch_t *pmatch, int nregs,
 	      int regs_allocated)
 {
   int rval = REGS_REALLOCATE;
-  Idx i;
-  Idx need_regs = nregs + 1;
-  /* We need one extra element beyond 'num_regs' for the '-1' marker GNU code
+  int i;
+  int need_regs = nregs + 1;
+  /* We need one extra element beyond `num_regs' for the `-1' marker GNU code
      uses.  */
 
   /* Have the register data arrays been allocated?  */
@@ -534,7 +530,7 @@ re_copy_regs (struct re_registers *regs, regmatch_t *pmatch, Idx nregs,
 
 void
 re_set_registers (struct re_pattern_buffer *bufp, struct re_registers *regs,
-		  __re_size_t num_regs, regoff_t *starts, regoff_t *ends)
+		  unsigned num_regs, regoff_t *starts, regoff_t *ends)
 {
   if (num_regs)
     {
@@ -547,7 +543,7 @@ re_set_registers (struct re_pattern_buffer *bufp, struct re_registers *regs,
     {
       bufp->regs_allocated = REGS_UNALLOCATED;
       regs->num_regs = 0;
-      regs->start = regs->end = NULL;
+      regs->start = regs->end = (regoff_t *) 0;
     }
 }
 #ifdef _LIBC
@@ -572,38 +568,32 @@ re_exec (const char *s)
 
 /* Searches for a compiled pattern PREG in the string STRING, whose
    length is LENGTH.  NMATCH, PMATCH, and EFLAGS have the same
-   meaning as with regexec.  LAST_START is START + RANGE, where
-   START and RANGE have the same meaning as with re_search.
+   meaning as with regexec.  START, and RANGE have the same meanings
+   with re_search.
    Return REG_NOERROR if we find a match, and REG_NOMATCH if not,
    otherwise return the error code.
    Note: We assume front end functions already check ranges.
-   (0 <= LAST_START && LAST_START <= LENGTH)  */
+   (START + RANGE >= 0 && START + RANGE <= LENGTH)  */
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-re_search_internal (const regex_t *preg, const char *string, Idx length,
-		    Idx start, Idx last_start, Idx stop, size_t nmatch,
+re_search_internal (const regex_t *preg, const char *string, int length,
+		    int start, int range, int stop, size_t nmatch,
 		    regmatch_t pmatch[], int eflags)
 {
   reg_errcode_t err;
-  const re_dfa_t *dfa = preg->buffer;
-  Idx left_lim, right_lim;
-  int incr;
-  bool fl_longest_match;
-  int match_kind;
-  Idx match_first;
-  Idx match_last = -1;
-  Idx extra_nmatch;
-  bool sb;
-  int ch;
+  const re_dfa_t *dfa = (const re_dfa_t *) preg->buffer;
+  int left_lim, right_lim, incr;
+  int fl_longest_match, match_first, match_kind, match_last = -1;
+  int extra_nmatch;
+  int sb, ch;
 #if defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)
   re_match_context_t mctx = { .dfa = dfa };
 #else
   re_match_context_t mctx;
 #endif
-  char *fastmap = ((preg->fastmap != NULL && preg->fastmap_accurate
-		    && start != last_start && !preg->can_be_null)
-		   ? preg->fastmap : NULL);
+  char *fastmap = (preg->fastmap != NULL && preg->fastmap_accurate
+		   && range && !preg->can_be_null) ? preg->fastmap : NULL;
   RE_TRANSLATE_TYPE t = preg->translate;
 
 #if !(defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))
@@ -622,7 +612,7 @@ re_search_internal (const regex_t *preg, const char *string, Idx length,
 
 #ifdef DEBUG
   /* We assume front-end functions already check them.  */
-  assert (0 <= last_start && last_start <= length);
+  assert (start + range >= 0 && start + range <= length);
 #endif
 
   /* If initial states with non-begbuf contexts have no elements,
@@ -633,17 +623,16 @@ re_search_internal (const regex_t *preg, const char *string, Idx length,
       && (dfa->init_state_nl->nodes.nelem == 0
 	  || !preg->newline_anchor))
     {
-      if (start != 0 && last_start != 0)
-        return REG_NOMATCH;
-      start = last_start = 0;
+      if (start != 0 && start + range != 0)
+	return REG_NOMATCH;
+      start = range = 0;
     }
 
   /* We must check the longest matching, if nmatch > 0.  */
   fl_longest_match = (nmatch != 0 || dfa->nbackref);
 
   err = re_string_allocate (&mctx.input, string, length, dfa->nodes_len + 1,
-			    preg->translate, (preg->syntax & RE_ICASE) != 0,
-			    dfa);
+			    preg->translate, preg->syntax & RE_ICASE, dfa);
   if (BE (err != REG_NOERROR, 0))
     goto free_return;
   mctx.input.stop = stop;
@@ -661,8 +650,7 @@ re_search_internal (const regex_t *preg, const char *string, Idx length,
   if (nmatch > 1 || dfa->has_mb_node)
     {
       /* Avoid overflow.  */
-      if (BE ((MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *))
-               <= mctx.input.bufs_len), 0))
+      if (BE (SIZE_MAX / sizeof (re_dfastate_t *) <= mctx.input.bufs_len, 0))
 	{
 	  err = REG_ESPACE;
 	  goto free_return;
@@ -682,15 +670,15 @@ re_search_internal (const regex_t *preg, const char *string, Idx length,
   mctx.input.tip_context = (eflags & REG_NOTBOL) ? CONTEXT_BEGBUF
 			   : CONTEXT_NEWLINE | CONTEXT_BEGBUF;
 
-  /* Check incrementally whether the input string matches.  */
-  incr = (last_start < start) ? -1 : 1;
-  left_lim = (last_start < start) ? last_start : start;
-  right_lim = (last_start < start) ? start : last_start;
+  /* Check incrementally whether of not the input string match.  */
+  incr = (range < 0) ? -1 : 1;
+  left_lim = (range < 0) ? start + range : start;
+  right_lim = (range < 0) ? start : start + range;
   sb = dfa->mb_cur_max == 1;
   match_kind =
     (fastmap
      ? ((sb || !(preg->syntax & RE_ICASE || t) ? 4 : 0)
-	| (start <= last_start ? 2 : 0)
+	| (range >= 0 ? 2 : 0)
 	| (t != NULL ? 1 : 0))
      : 8);
 
@@ -757,8 +745,8 @@ re_search_internal (const regex_t *preg, const char *string, Idx length,
 	    {
 	      /* If MATCH_FIRST is out of the valid range, reconstruct the
 		 buffers.  */
-	      __re_size_t offset = match_first - mctx.input.raw_mbs_idx;
-	      if (BE (offset >= (__re_size_t) mctx.input.valid_raw_len, 0))
+	      unsigned int offset = match_first - mctx.input.raw_mbs_idx;
+	      if (BE (offset >= (unsigned int) mctx.input.valid_raw_len, 0))
 		{
 		  err = re_string_reconstruct (&mctx.input, match_first,
 					       eflags);
@@ -800,7 +788,7 @@ re_search_internal (const regex_t *preg, const char *string, Idx length,
       /* We assume that the matching starts from 0.  */
       mctx.state_log_top = mctx.nbkref_ents = mctx.max_mb_elem_len = 0;
       match_last = check_matching (&mctx, fl_longest_match,
-				   start <= last_start ? &match_first : NULL);
+				   range >= 0 ? &match_first : NULL);
       if (match_last != -1)
 	{
 	  if (BE (match_last == -2, 0))
@@ -843,7 +831,7 @@ re_search_internal (const regex_t *preg, const char *string, Idx length,
   /* Set pmatch[] if we need.  */
   if (nmatch > 0)
     {
-      Idx reg_idx;
+      int reg_idx;
 
       /* Initialize registers.  */
       for (reg_idx = 1; reg_idx < nmatch; ++reg_idx)
@@ -852,9 +840,6 @@ re_search_internal (const regex_t *preg, const char *string, Idx length,
       /* Set the points where matching start/end.  */
       pmatch[0].rm_so = 0;
       pmatch[0].rm_eo = mctx.match_last;
-      /* FIXME: This function should fail if mctx.match_last exceeds
-	 the maximum possible regoff_t value.  We need a new error
-	 code REG_OVERFLOW.  */
 
       if (!preg->no_sub && nmatch > 1)
 	{
@@ -918,7 +903,7 @@ __attribute_warn_unused_result__
 prune_impossible_nodes (re_match_context_t *mctx)
 {
   const re_dfa_t *const dfa = mctx->dfa;
-  Idx halt_node, match_last;
+  int halt_node, match_last;
   reg_errcode_t ret;
   re_dfastate_t **sifted_states;
   re_dfastate_t **lim_states = NULL;
@@ -930,7 +915,7 @@ prune_impossible_nodes (re_match_context_t *mctx)
   halt_node = mctx->last_node;
 
   /* Avoid overflow.  */
-  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) <= match_last, 0))
+  if (BE (SIZE_MAX / sizeof (re_dfastate_t *) <= match_last, 0))
     return REG_ESPACE;
 
   sifted_states = re_malloc (re_dfastate_t *, match_last + 1);
@@ -1010,9 +995,9 @@ prune_impossible_nodes (re_match_context_t *mctx)
    since initial states may have constraints like "\<", "^", etc..  */
 
 static inline re_dfastate_t *
-__attribute__ ((always_inline))
+__attribute ((always_inline))
 acquire_init_state_context (reg_errcode_t *err, const re_match_context_t *mctx,
-			    Idx idx)
+			    int idx)
 {
   const re_dfa_t *const dfa = mctx->dfa;
   if (dfa->init_state->has_constraint)
@@ -1043,27 +1028,27 @@ acquire_init_state_context (reg_errcode_t *err, const re_match_context_t *mctx,
 }
 
 /* Check whether the regular expression match input string INPUT or not,
-   and return the index where the matching end.  Return -1 if
-   there is no match, and return -2 in case of an error.
+   and return the index where the matching end, return -1 if not match,
+   or return -2 in case of an error.
    FL_LONGEST_MATCH means we want the POSIX longest matching.
    If P_MATCH_FIRST is not NULL, and the match fails, it is set to the
    next place where we may want to try matching.
-   Note that the matcher assumes that the matching starts from the current
+   Note that the matcher assume that the maching starts from the current
    index of the buffer.  */
 
-static Idx
+static int
 __attribute_warn_unused_result__
-check_matching (re_match_context_t *mctx, bool fl_longest_match,
-		Idx *p_match_first)
+check_matching (re_match_context_t *mctx, int fl_longest_match,
+		int *p_match_first)
 {
   const re_dfa_t *const dfa = mctx->dfa;
   reg_errcode_t err;
-  Idx match = 0;
-  Idx match_last = -1;
-  Idx cur_str_idx = re_string_cur_idx (&mctx->input);
+  int match = 0;
+  int match_last = -1;
+  int cur_str_idx = re_string_cur_idx (&mctx->input);
   re_dfastate_t *cur_state;
-  bool at_init_state = p_match_first != NULL;
-  Idx next_start_idx = cur_str_idx;
+  int at_init_state = p_match_first != NULL;
+  int next_start_idx = cur_str_idx;
 
   err = REG_NOERROR;
   cur_state = acquire_init_state_context (&err, mctx, cur_str_idx);
@@ -1082,7 +1067,7 @@ check_matching (re_match_context_t *mctx, bool fl_longest_match,
 	 later.  E.g. Processing back references.  */
       if (BE (dfa->nbackref, 0))
 	{
-	  at_init_state = false;
+	  at_init_state = 0;
 	  err = check_subexp_matching_top (mctx, &cur_state->nodes, 0);
 	  if (BE (err != REG_NOERROR, 0))
 	    return err;
@@ -1115,7 +1100,7 @@ check_matching (re_match_context_t *mctx, bool fl_longest_match,
   while (!re_string_eoi (&mctx->input))
     {
       re_dfastate_t *old_state = cur_state;
-      Idx next_char_idx = re_string_cur_idx (&mctx->input) + 1;
+      int next_char_idx = re_string_cur_idx (&mctx->input) + 1;
 
       if ((BE (next_char_idx >= mctx->input.bufs_len, 0)
 	   && mctx->input.bufs_len < mctx->input.len)
@@ -1153,7 +1138,7 @@ check_matching (re_match_context_t *mctx, bool fl_longest_match,
 	  if (old_state == cur_state)
 	    next_start_idx = next_char_idx;
 	  else
-	    at_init_state = false;
+	    at_init_state = 0;
 	}
 
       if (cur_state->halt)
@@ -1184,29 +1169,29 @@ check_matching (re_match_context_t *mctx, bool fl_longest_match,
 
 /* Check NODE match the current context.  */
 
-static bool
-check_halt_node_context (const re_dfa_t *dfa, Idx node, unsigned int context)
+static int
+check_halt_node_context (const re_dfa_t *dfa, int node, unsigned int context)
 {
   re_token_type_t type = dfa->nodes[node].type;
   unsigned int constraint = dfa->nodes[node].constraint;
   if (type != END_OF_RE)
-    return false;
+    return 0;
   if (!constraint)
-    return true;
+    return 1;
   if (NOT_SATISFY_NEXT_CONSTRAINT (constraint, context))
-    return false;
-  return true;
+    return 0;
+  return 1;
 }
 
 /* Check the halt state STATE match the current context.
    Return 0 if not match, if the node, STATE has, is a halt node and
    match the context, return the node.  */
 
-static Idx
+static int
 check_halt_state_context (const re_match_context_t *mctx,
-			  const re_dfastate_t *state, Idx idx)
+			  const re_dfastate_t *state, int idx)
 {
-  Idx i;
+  int i;
   unsigned int context;
 #ifdef DEBUG
   assert (state->halt);
@@ -1220,33 +1205,31 @@ check_halt_state_context (const re_match_context_t *mctx,
 
 /* Compute the next node to which "NFA" transit from NODE("NFA" is a NFA
    corresponding to the DFA).
-   Return the destination node, and update EPS_VIA_NODES;
-   return -1 in case of errors.  */
+   Return the destination node, and update EPS_VIA_NODES, return -1 in case
+   of errors.  */
 
-static Idx
-proceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,
-		   Idx *pidx, Idx node, re_node_set *eps_via_nodes,
+static int
+proceed_next_node (const re_match_context_t *mctx, int nregs, regmatch_t *regs,
+		   int *pidx, int node, re_node_set *eps_via_nodes,
 		   struct re_fail_stack_t *fs)
 {
   const re_dfa_t *const dfa = mctx->dfa;
-  Idx i;
-  bool ok;
+  int i, err;
   if (IS_EPSILON_NODE (dfa->nodes[node].type))
     {
       re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;
       re_node_set *edests = &dfa->edests[node];
-      Idx dest_node;
-      ok = re_node_set_insert (eps_via_nodes, node);
-      if (BE (! ok, 0))
+      int dest_node;
+      err = re_node_set_insert (eps_via_nodes, node);
+      if (BE (err < 0, 0))
 	return -2;
-      /* Pick up a valid destination, or return -1 if none
-	 is found.  */
+      /* Pick up a valid destination, or return -1 if none is found.  */
       for (dest_node = -1, i = 0; i < edests->nelem; ++i)
 	{
-	  Idx candidate = edests->elems[i];
+	  int candidate = edests->elems[i];
 	  if (!re_node_set_contains (cur_nodes, candidate))
 	    continue;
-          if (dest_node == -1)
+	  if (dest_node == -1)
 	    dest_node = candidate;
 
 	  else
@@ -1270,7 +1253,7 @@ proceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,
     }
   else
     {
-      Idx naccepted = 0;
+      int naccepted = 0;
       re_token_type_t type = dfa->nodes[node].type;
 
 #ifdef RE_ENABLE_I18N
@@ -1280,7 +1263,7 @@ proceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,
 #endif /* RE_ENABLE_I18N */
       if (type == OP_BACK_REF)
 	{
-	  Idx subexp_idx = dfa->nodes[node].opr.idx + 1;
+	  int subexp_idx = dfa->nodes[node].opr.idx + 1;
 	  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;
 	  if (fs != NULL)
 	    {
@@ -1289,19 +1272,17 @@ proceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,
 	      else if (naccepted)
 		{
 		  char *buf = (char *) re_string_get_buffer (&mctx->input);
-		  if (mctx->input.valid_len - *pidx < naccepted
-		      || (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,
-				  naccepted)
-			  != 0))
+		  if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,
+			      naccepted) != 0)
 		    return -1;
 		}
 	    }
 
 	  if (naccepted == 0)
 	    {
-	      Idx dest_node;
-	      ok = re_node_set_insert (eps_via_nodes, node);
-	      if (BE (! ok, 0))
+	      int dest_node;
+	      err = re_node_set_insert (eps_via_nodes, node);
+	      if (BE (err < 0, 0))
 		return -2;
 	      dest_node = dfa->edests[node].elems[0];
 	      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,
@@ -1313,7 +1294,7 @@ proceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,
       if (naccepted != 0
 	  || check_node_accept (mctx, dfa->nodes + node, *pidx))
 	{
-	  Idx dest_node = dfa->nexts[node];
+	  int dest_node = dfa->nexts[node];
 	  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;
 	  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL
 		     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,
@@ -1328,16 +1309,16 @@ proceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-push_fail_stack (struct re_fail_stack_t *fs, Idx str_idx, Idx dest_node,
-		 Idx nregs, regmatch_t *regs, re_node_set *eps_via_nodes)
+push_fail_stack (struct re_fail_stack_t *fs, int str_idx, int dest_node,
+		 int nregs, regmatch_t *regs, re_node_set *eps_via_nodes)
 {
   reg_errcode_t err;
-  Idx num = fs->num++;
+  int num = fs->num++;
   if (fs->num == fs->alloc)
     {
       struct re_fail_stack_ent_t *new_array;
-      new_array = re_realloc (fs->stack, struct re_fail_stack_ent_t,
-                              fs->alloc * 2);
+      new_array = realloc (fs->stack, (sizeof (struct re_fail_stack_ent_t)
+				       * fs->alloc * 2));
       if (new_array == NULL)
 	return REG_ESPACE;
       fs->alloc *= 2;
@@ -1353,11 +1334,11 @@ push_fail_stack (struct re_fail_stack_t *fs, Idx str_idx, Idx dest_node,
   return err;
 }
 
-static Idx
-pop_fail_stack (struct re_fail_stack_t *fs, Idx *pidx, Idx nregs,
+static int
+pop_fail_stack (struct re_fail_stack_t *fs, int *pidx, int nregs,
 		regmatch_t *regs, re_node_set *eps_via_nodes)
 {
-  Idx num = --fs->num;
+  int num = --fs->num;
   assert (num >= 0);
   *pidx = fs->stack[num].idx;
   memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);
@@ -1375,15 +1356,15 @@ pop_fail_stack (struct re_fail_stack_t *fs, Idx *pidx, Idx nregs,
 static reg_errcode_t
 __attribute_warn_unused_result__
 set_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,
-	  regmatch_t *pmatch, bool fl_backtrack)
+	  regmatch_t *pmatch, int fl_backtrack)
 {
-  const re_dfa_t *dfa = preg->buffer;
-  Idx idx, cur_node;
+  const re_dfa_t *dfa = (const re_dfa_t *) preg->buffer;
+  int idx, cur_node;
   re_node_set eps_via_nodes;
   struct re_fail_stack_t *fs;
   struct re_fail_stack_t fs_body = { 0, 2, NULL };
   regmatch_t *prev_idx_match;
-  bool prev_idx_match_malloced = false;
+  int prev_idx_match_malloced = 0;
 
 #ifdef DEBUG
   assert (nmatch > 1);
@@ -1412,7 +1393,7 @@ set_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,
 	  free_fail_stack_return (fs);
 	  return REG_ESPACE;
 	}
-      prev_idx_match_malloced = true;
+      prev_idx_match_malloced = 1;
     }
   memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);
 
@@ -1422,7 +1403,7 @@ set_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,
 
       if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)
 	{
-	  Idx reg_idx;
+	  int reg_idx;
 	  if (fs)
 	    {
 	      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)
@@ -1484,7 +1465,7 @@ free_fail_stack_return (struct re_fail_stack_t *fs)
 {
   if (fs)
     {
-      Idx fs_idx;
+      int fs_idx;
       for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)
 	{
 	  re_node_set_free (&fs->stack[fs_idx].eps_via_nodes);
@@ -1497,12 +1478,12 @@ free_fail_stack_return (struct re_fail_stack_t *fs)
 
 static void
 update_regs (const re_dfa_t *dfa, regmatch_t *pmatch,
-	     regmatch_t *prev_idx_match, Idx cur_node, Idx cur_idx, Idx nmatch)
+	     regmatch_t *prev_idx_match, int cur_node, int cur_idx, int nmatch)
 {
   int type = dfa->nodes[cur_node].type;
   if (type == OP_OPEN_SUBEXP)
     {
-      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;
+      int reg_num = dfa->nodes[cur_node].opr.idx + 1;
 
       /* We are at the first node of this sub expression.  */
       if (reg_num < nmatch)
@@ -1513,7 +1494,7 @@ update_regs (const re_dfa_t *dfa, regmatch_t *pmatch,
     }
   else if (type == OP_CLOSE_SUBEXP)
     {
-      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;
+      int reg_num = dfa->nodes[cur_node].opr.idx + 1;
       if (reg_num < nmatch)
 	{
 	  /* We are at the last node of this sub expression.  */
@@ -1547,21 +1528,21 @@ update_regs (const re_dfa_t *dfa, regmatch_t *pmatch,
    and sift the nodes in each states according to the following rules.
    Updated state_log will be wrote to STATE_LOG.
 
-   Rules: We throw away the Node 'a' in the STATE_LOG[STR_IDX] if...
+   Rules: We throw away the Node `a' in the STATE_LOG[STR_IDX] if...
      1. When STR_IDX == MATCH_LAST(the last index in the state_log):
-	If 'a' isn't the LAST_NODE and 'a' can't epsilon transit to
-	the LAST_NODE, we throw away the node 'a'.
-     2. When 0 <= STR_IDX < MATCH_LAST and 'a' accepts
-	string 's' and transit to 'b':
+	If `a' isn't the LAST_NODE and `a' can't epsilon transit to
+	the LAST_NODE, we throw away the node `a'.
+     2. When 0 <= STR_IDX < MATCH_LAST and `a' accepts
+	string `s' and transit to `b':
 	i. If 'b' isn't in the STATE_LOG[STR_IDX+strlen('s')], we throw
-	   away the node 'a'.
+	   away the node `a'.
 	ii. If 'b' is in the STATE_LOG[STR_IDX+strlen('s')] but 'b' is
-	    thrown away, we throw away the node 'a'.
+	    thrown away, we throw away the node `a'.
      3. When 0 <= STR_IDX < MATCH_LAST and 'a' epsilon transit to 'b':
 	i. If 'b' isn't in the STATE_LOG[STR_IDX], we throw away the
-	   node 'a'.
+	   node `a'.
 	ii. If 'b' is in the STATE_LOG[STR_IDX] but 'b' is thrown away,
-	    we throw away the node 'a'.  */
+	    we throw away the node `a'.  */
 
 #define STATE_NODE_CONTAINS(state,node) \
   ((state) != NULL && re_node_set_contains (&(state)->nodes, node))
@@ -1571,7 +1552,7 @@ sift_states_backward (const re_match_context_t *mctx, re_sift_context_t *sctx)
 {
   reg_errcode_t err;
   int null_cnt = 0;
-  Idx str_idx = sctx->last_str_idx;
+  int str_idx = sctx->last_str_idx;
   re_node_set cur_dest;
 
 #ifdef DEBUG
@@ -1626,31 +1607,31 @@ sift_states_backward (const re_match_context_t *mctx, re_sift_context_t *sctx)
 static reg_errcode_t
 __attribute_warn_unused_result__
 build_sifted_states (const re_match_context_t *mctx, re_sift_context_t *sctx,
-		     Idx str_idx, re_node_set *cur_dest)
+		     int str_idx, re_node_set *cur_dest)
 {
   const re_dfa_t *const dfa = mctx->dfa;
   const re_node_set *cur_src = &mctx->state_log[str_idx]->non_eps_nodes;
-  Idx i;
+  int i;
 
   /* Then build the next sifted state.
-     We build the next sifted state on 'cur_dest', and update
-     'sifted_states[str_idx]' with 'cur_dest'.
+     We build the next sifted state on `cur_dest', and update
+     `sifted_states[str_idx]' with `cur_dest'.
      Note:
-     'cur_dest' is the sifted state from 'state_log[str_idx + 1]'.
-     'cur_src' points the node_set of the old 'state_log[str_idx]'
+     `cur_dest' is the sifted state from `state_log[str_idx + 1]'.
+     `cur_src' points the node_set of the old `state_log[str_idx]'
      (with the epsilon nodes pre-filtered out).  */
   for (i = 0; i < cur_src->nelem; i++)
     {
-      Idx prev_node = cur_src->elems[i];
+      int prev_node = cur_src->elems[i];
       int naccepted = 0;
-      bool ok;
+      int ret;
 
 #ifdef DEBUG
       re_token_type_t type = dfa->nodes[prev_node].type;
       assert (!IS_EPSILON_NODE (type));
 #endif
 #ifdef RE_ENABLE_I18N
-      /* If the node may accept "multi byte".  */
+      /* If the node may accept `multi byte'.  */
       if (dfa->nodes[prev_node].accept_mb)
 	naccepted = sift_states_iter_mb (mctx, sctx, prev_node,
 					 str_idx, sctx->last_str_idx);
@@ -1669,14 +1650,14 @@ build_sifted_states (const re_match_context_t *mctx, re_sift_context_t *sctx,
 
       if (sctx->limits.nelem)
 	{
-	  Idx to_idx = str_idx + naccepted;
+	  int to_idx = str_idx + naccepted;
 	  if (check_dst_limits (mctx, &sctx->limits,
 				dfa->nexts[prev_node], to_idx,
 				prev_node, str_idx))
 	    continue;
 	}
-      ok = re_node_set_insert (cur_dest, prev_node);
-      if (BE (! ok, 0))
+      ret = re_node_set_insert (cur_dest, prev_node);
+      if (BE (ret == -1, 0))
 	return REG_ESPACE;
     }
 
@@ -1686,9 +1667,9 @@ build_sifted_states (const re_match_context_t *mctx, re_sift_context_t *sctx,
 /* Helper functions.  */
 
 static reg_errcode_t
-clean_state_log_if_needed (re_match_context_t *mctx, Idx next_state_log_idx)
+clean_state_log_if_needed (re_match_context_t *mctx, int next_state_log_idx)
 {
-  Idx top = mctx->state_log_top;
+  int top = mctx->state_log_top;
 
   if ((next_state_log_idx >= mctx->input.bufs_len
        && mctx->input.bufs_len < mctx->input.len)
@@ -1712,9 +1693,9 @@ clean_state_log_if_needed (re_match_context_t *mctx, Idx next_state_log_idx)
 
 static reg_errcode_t
 merge_state_array (const re_dfa_t *dfa, re_dfastate_t **dst,
-		   re_dfastate_t **src, Idx num)
+		   re_dfastate_t **src, int num)
 {
-  Idx st_idx;
+  int st_idx;
   reg_errcode_t err;
   for (st_idx = 0; st_idx < num; ++st_idx)
     {
@@ -1738,7 +1719,7 @@ merge_state_array (const re_dfa_t *dfa, re_dfastate_t **dst,
 
 static reg_errcode_t
 update_cur_sifted_state (const re_match_context_t *mctx,
-			 re_sift_context_t *sctx, Idx str_idx,
+			 re_sift_context_t *sctx, int str_idx,
 			 re_node_set *dest_nodes)
 {
   const re_dfa_t *const dfa = mctx->dfa;
@@ -1789,7 +1770,7 @@ add_epsilon_src_nodes (const re_dfa_t *dfa, re_node_set *dest_nodes,
 		       const re_node_set *candidates)
 {
   reg_errcode_t err = REG_NOERROR;
-  Idx i;
+  int i;
 
   re_dfastate_t *state = re_acquire_state (&err, dfa, dest_nodes);
   if (BE (err != REG_NOERROR, 0))
@@ -1813,23 +1794,23 @@ add_epsilon_src_nodes (const re_dfa_t *dfa, re_node_set *dest_nodes,
 }
 
 static reg_errcode_t
-sub_epsilon_src_nodes (const re_dfa_t *dfa, Idx node, re_node_set *dest_nodes,
+sub_epsilon_src_nodes (const re_dfa_t *dfa, int node, re_node_set *dest_nodes,
 		       const re_node_set *candidates)
 {
-    Idx ecl_idx;
+    int ecl_idx;
     reg_errcode_t err;
     re_node_set *inv_eclosure = dfa->inveclosures + node;
     re_node_set except_nodes;
     re_node_set_init_empty (&except_nodes);
     for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)
       {
-	Idx cur_node = inv_eclosure->elems[ecl_idx];
+	int cur_node = inv_eclosure->elems[ecl_idx];
 	if (cur_node == node)
 	  continue;
 	if (IS_EPSILON_NODE (dfa->nodes[cur_node].type))
 	  {
-	    Idx edst1 = dfa->edests[cur_node].elems[0];
-	    Idx edst2 = ((dfa->edests[cur_node].nelem > 1)
+	    int edst1 = dfa->edests[cur_node].elems[0];
+	    int edst2 = ((dfa->edests[cur_node].nelem > 1)
 			 ? dfa->edests[cur_node].elems[1] : -1);
 	    if ((!re_node_set_contains (inv_eclosure, edst1)
 		 && re_node_set_contains (dest_nodes, edst1))
@@ -1849,10 +1830,10 @@ sub_epsilon_src_nodes (const re_dfa_t *dfa, Idx node, re_node_set *dest_nodes,
       }
     for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)
       {
-	Idx cur_node = inv_eclosure->elems[ecl_idx];
+	int cur_node = inv_eclosure->elems[ecl_idx];
 	if (!re_node_set_contains (&except_nodes, cur_node))
 	  {
-	    Idx idx = re_node_set_contains (dest_nodes, cur_node) - 1;
+	    int idx = re_node_set_contains (dest_nodes, cur_node) - 1;
 	    re_node_set_remove_at (dest_nodes, idx);
 	  }
       }
@@ -1860,18 +1841,18 @@ sub_epsilon_src_nodes (const re_dfa_t *dfa, Idx node, re_node_set *dest_nodes,
     return REG_NOERROR;
 }
 
-static bool
-check_dst_limits (const re_match_context_t *mctx, const re_node_set *limits,
-		  Idx dst_node, Idx dst_idx, Idx src_node, Idx src_idx)
+static int
+check_dst_limits (const re_match_context_t *mctx, re_node_set *limits,
+		  int dst_node, int dst_idx, int src_node, int src_idx)
 {
   const re_dfa_t *const dfa = mctx->dfa;
-  Idx lim_idx, src_pos, dst_pos;
+  int lim_idx, src_pos, dst_pos;
 
-  Idx dst_bkref_idx = search_cur_bkref_entry (mctx, dst_idx);
-  Idx src_bkref_idx = search_cur_bkref_entry (mctx, src_idx);
+  int dst_bkref_idx = search_cur_bkref_entry (mctx, dst_idx);
+  int src_bkref_idx = search_cur_bkref_entry (mctx, src_idx);
   for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)
     {
-      Idx subexp_idx;
+      int subexp_idx;
       struct re_backref_cache_entry *ent;
       ent = mctx->bkref_ents + limits->elems[lim_idx];
       subexp_idx = dfa->nodes[ent->node].opr.idx;
@@ -1890,24 +1871,24 @@ check_dst_limits (const re_match_context_t *mctx, const re_node_set *limits,
       if (src_pos == dst_pos)
 	continue; /* This is unrelated limitation.  */
       else
-	return true;
+	return 1;
     }
-  return false;
+  return 0;
 }
 
 static int
 check_dst_limits_calc_pos_1 (const re_match_context_t *mctx, int boundaries,
-			     Idx subexp_idx, Idx from_node, Idx bkref_idx)
+			     int subexp_idx, int from_node, int bkref_idx)
 {
   const re_dfa_t *const dfa = mctx->dfa;
   const re_node_set *eclosures = dfa->eclosures + from_node;
-  Idx node_idx;
+  int node_idx;
 
   /* Else, we are on the boundary: examine the nodes on the epsilon
      closure.  */
   for (node_idx = 0; node_idx < eclosures->nelem; ++node_idx)
     {
-      Idx node = eclosures->elems[node_idx];
+      int node = eclosures->elems[node_idx];
       switch (dfa->nodes[node].type)
 	{
 	case OP_BACK_REF:
@@ -1916,8 +1897,7 @@ check_dst_limits_calc_pos_1 (const re_match_context_t *mctx, int boundaries,
 	      struct re_backref_cache_entry *ent = mctx->bkref_ents + bkref_idx;
 	      do
 		{
-		  Idx dst;
-		  int cpos;
+		  int dst, cpos;
 
 		  if (ent->node != node)
 		    continue;
@@ -1977,9 +1957,9 @@ check_dst_limits_calc_pos_1 (const re_match_context_t *mctx, int boundaries,
 }
 
 static int
-check_dst_limits_calc_pos (const re_match_context_t *mctx, Idx limit,
-			   Idx subexp_idx, Idx from_node, Idx str_idx,
-			   Idx bkref_idx)
+check_dst_limits_calc_pos (const re_match_context_t *mctx, int limit,
+			   int subexp_idx, int from_node, int str_idx,
+			   int bkref_idx)
 {
   struct re_backref_cache_entry *lim = mctx->bkref_ents + limit;
   int boundaries;
@@ -2008,14 +1988,14 @@ check_dst_limits_calc_pos (const re_match_context_t *mctx, Idx limit,
 static reg_errcode_t
 check_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,
 		     const re_node_set *candidates, re_node_set *limits,
-		     struct re_backref_cache_entry *bkref_ents, Idx str_idx)
+		     struct re_backref_cache_entry *bkref_ents, int str_idx)
 {
   reg_errcode_t err;
-  Idx node_idx, lim_idx;
+  int node_idx, lim_idx;
 
   for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)
     {
-      Idx subexp_idx;
+      int subexp_idx;
       struct re_backref_cache_entry *ent;
       ent = bkref_ents + limits->elems[lim_idx];
 
@@ -2025,11 +2005,11 @@ check_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,
       subexp_idx = dfa->nodes[ent->node].opr.idx;
       if (ent->subexp_to == str_idx)
 	{
-	  Idx ops_node = -1;
-	  Idx cls_node = -1;
+	  int ops_node = -1;
+	  int cls_node = -1;
 	  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)
 	    {
-	      Idx node = dest_nodes->elems[node_idx];
+	      int node = dest_nodes->elems[node_idx];
 	      re_token_type_t type = dfa->nodes[node].type;
 	      if (type == OP_OPEN_SUBEXP
 		  && subexp_idx == dfa->nodes[node].opr.idx)
@@ -2053,7 +2033,7 @@ check_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,
 	  if (cls_node >= 0)
 	    for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)
 	      {
-		Idx node = dest_nodes->elems[node_idx];
+		int node = dest_nodes->elems[node_idx];
 		if (!re_node_set_contains (dfa->inveclosures + node,
 					   cls_node)
 		    && !re_node_set_contains (dfa->eclosures + node,
@@ -2073,7 +2053,7 @@ check_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,
 	{
 	  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)
 	    {
-	      Idx node = dest_nodes->elems[node_idx];
+	      int node = dest_nodes->elems[node_idx];
 	      re_token_type_t type = dfa->nodes[node].type;
 	      if (type == OP_CLOSE_SUBEXP || type == OP_OPEN_SUBEXP)
 		{
@@ -2095,13 +2075,13 @@ check_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,
 static reg_errcode_t
 __attribute_warn_unused_result__
 sift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,
-		   Idx str_idx, const re_node_set *candidates)
+		   int str_idx, const re_node_set *candidates)
 {
   const re_dfa_t *const dfa = mctx->dfa;
   reg_errcode_t err;
-  Idx node_idx, node;
+  int node_idx, node;
   re_sift_context_t local_sctx;
-  Idx first_idx = search_cur_bkref_entry (mctx, str_idx);
+  int first_idx = search_cur_bkref_entry (mctx, str_idx);
 
   if (first_idx == -1)
     return REG_NOERROR;
@@ -2110,7 +2090,7 @@ sift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,
 
   for (node_idx = 0; node_idx < candidates->nelem; ++node_idx)
     {
-      Idx enabled_idx;
+      int enabled_idx;
       re_token_type_t type;
       struct re_backref_cache_entry *entry;
       node = candidates->elems[node_idx];
@@ -2125,10 +2105,10 @@ sift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,
       enabled_idx = first_idx;
       do
 	{
-	  Idx subexp_len;
-	  Idx to_idx;
-	  Idx dst_node;
-	  bool ok;
+	  int subexp_len;
+	  int to_idx;
+	  int dst_node;
+	  int ret;
 	  re_dfastate_t *cur_state;
 
 	  if (entry->node != node)
@@ -2154,8 +2134,8 @@ sift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,
 	    }
 	  local_sctx.last_node = node;
 	  local_sctx.last_str_idx = str_idx;
-	  ok = re_node_set_insert (&local_sctx.limits, enabled_idx);
-	  if (BE (! ok, 0))
+	  ret = re_node_set_insert (&local_sctx.limits, enabled_idx);
+	  if (BE (ret < 0, 0))
 	    {
 	      err = REG_ESPACE;
 	      goto free_return;
@@ -2194,21 +2174,21 @@ sift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,
 #ifdef RE_ENABLE_I18N
 static int
 sift_states_iter_mb (const re_match_context_t *mctx, re_sift_context_t *sctx,
-		     Idx node_idx, Idx str_idx, Idx max_str_idx)
+		     int node_idx, int str_idx, int max_str_idx)
 {
   const re_dfa_t *const dfa = mctx->dfa;
   int naccepted;
-  /* Check the node can accept "multi byte".  */
+  /* Check the node can accept `multi byte'.  */
   naccepted = check_node_accept_bytes (dfa, node_idx, &mctx->input, str_idx);
   if (naccepted > 0 && str_idx + naccepted <= max_str_idx &&
       !STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + naccepted],
 			    dfa->nexts[node_idx]))
-    /* The node can't accept the "multi byte", or the
+    /* The node can't accept the `multi byte', or the
        destination was already thrown away, then the node
-       could't accept the current input "multi byte".   */
+       could't accept the current input `multi byte'.   */
     naccepted = 0;
   /* Otherwise, it is sure that the node could accept
-     'naccepted' bytes input.  */
+     `naccepted' bytes input.  */
   return naccepted;
 }
 #endif /* RE_ENABLE_I18N */
@@ -2279,12 +2259,12 @@ transit_state (reg_errcode_t *err, re_match_context_t *mctx,
 }
 
 /* Update the state_log if we need */
-static re_dfastate_t *
+re_dfastate_t *
 merge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,
 		      re_dfastate_t *next_state)
 {
   const re_dfa_t *const dfa = mctx->dfa;
-  Idx cur_idx = re_string_cur_idx (&mctx->input);
+  int cur_idx = re_string_cur_idx (&mctx->input);
 
   if (cur_idx > mctx->state_log_top)
     {
@@ -2357,14 +2337,14 @@ merge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,
 /* Skip bytes in the input that correspond to part of a
    multi-byte match, then look in the log for a state
    from which to restart matching.  */
-static re_dfastate_t *
+re_dfastate_t *
 find_recover_state (reg_errcode_t *err, re_match_context_t *mctx)
 {
   re_dfastate_t *cur_state;
   do
     {
-      Idx max = mctx->state_log_top;
-      Idx cur_str_idx = re_string_cur_idx (&mctx->input);
+      int max = mctx->state_log_top;
+      int cur_str_idx = re_string_cur_idx (&mctx->input);
 
       do
 	{
@@ -2389,10 +2369,10 @@ find_recover_state (reg_errcode_t *err, re_match_context_t *mctx)
 
 static reg_errcode_t
 check_subexp_matching_top (re_match_context_t *mctx, re_node_set *cur_nodes,
-			   Idx str_idx)
+			   int str_idx)
 {
   const re_dfa_t *const dfa = mctx->dfa;
-  Idx node_idx;
+  int node_idx;
   reg_errcode_t err;
 
   /* TODO: This isn't efficient.
@@ -2402,7 +2382,7 @@ check_subexp_matching_top (re_match_context_t *mctx, re_node_set *cur_nodes,
 	   E.g. RE: (a){2}  */
   for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)
     {
-      Idx node = cur_nodes->elems[node_idx];
+      int node = cur_nodes->elems[node_idx];
       if (dfa->nodes[node].type == OP_OPEN_SUBEXP
 	  && dfa->nodes[node].opr.idx < BITSET_WORD_BITS
 	  && (dfa->used_bkref_map
@@ -2427,7 +2407,7 @@ transit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,
   const re_dfa_t *const dfa = mctx->dfa;
   re_node_set next_nodes;
   re_dfastate_t *next_state;
-  Idx node_cnt, cur_str_idx = re_string_cur_idx (&mctx->input);
+  int node_cnt, cur_str_idx = re_string_cur_idx (&mctx->input);
   unsigned int context;
 
   *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);
@@ -2435,7 +2415,7 @@ transit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,
     return NULL;
   for (node_cnt = 0; node_cnt < state->nodes.nelem; ++node_cnt)
     {
-      Idx cur_node = state->nodes.elems[node_cnt];
+      int cur_node = state->nodes.elems[node_cnt];
       if (check_node_accept (mctx, dfa->nodes + cur_node, cur_str_idx))
 	{
 	  *err = re_node_set_merge (&next_nodes,
@@ -2464,14 +2444,13 @@ transit_state_mb (re_match_context_t *mctx, re_dfastate_t *pstate)
 {
   const re_dfa_t *const dfa = mctx->dfa;
   reg_errcode_t err;
-  Idx i;
+  int i;
 
   for (i = 0; i < pstate->nodes.nelem; ++i)
     {
       re_node_set dest_nodes, *new_nodes;
-      Idx cur_node_idx = pstate->nodes.elems[i];
-      int naccepted;
-      Idx dest_idx;
+      int cur_node_idx = pstate->nodes.elems[i];
+      int naccepted, dest_idx;
       unsigned int context;
       re_dfastate_t *dest_state;
 
@@ -2494,7 +2473,7 @@ transit_state_mb (re_match_context_t *mctx, re_dfastate_t *pstate)
       if (naccepted == 0)
 	continue;
 
-      /* The node can accepts 'naccepted' bytes.  */
+      /* The node can accepts `naccepted' bytes.  */
       dest_idx = re_string_cur_idx (&mctx->input) + naccepted;
       mctx->max_mb_elem_len = ((mctx->max_mb_elem_len < naccepted) ? naccepted
 			       : mctx->max_mb_elem_len);
@@ -2534,18 +2513,18 @@ transit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)
 {
   const re_dfa_t *const dfa = mctx->dfa;
   reg_errcode_t err;
-  Idx i;
-  Idx cur_str_idx = re_string_cur_idx (&mctx->input);
+  int i;
+  int cur_str_idx = re_string_cur_idx (&mctx->input);
 
   for (i = 0; i < nodes->nelem; ++i)
     {
-      Idx dest_str_idx, prev_nelem, bkc_idx;
-      Idx node_idx = nodes->elems[i];
+      int dest_str_idx, prev_nelem, bkc_idx;
+      int node_idx = nodes->elems[i];
       unsigned int context;
       const re_token_t *node = dfa->nodes + node_idx;
       re_node_set *new_dest_nodes;
 
-      /* Check whether 'node' is a backreference or not.  */
+      /* Check whether `node' is a backreference or not.  */
       if (node->type != OP_BACK_REF)
 	continue;
 
@@ -2557,21 +2536,21 @@ transit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)
 	    continue;
 	}
 
-      /* 'node' is a backreference.
+      /* `node' is a backreference.
 	 Check the substring which the substring matched.  */
       bkc_idx = mctx->nbkref_ents;
       err = get_subexp (mctx, node_idx, cur_str_idx);
       if (BE (err != REG_NOERROR, 0))
 	goto free_return;
 
-      /* And add the epsilon closures (which is 'new_dest_nodes') of
+      /* And add the epsilon closures (which is `new_dest_nodes') of
 	 the backreference to appropriate state_log.  */
 #ifdef DEBUG
       assert (dfa->nexts[node_idx] != -1);
 #endif
       for (; bkc_idx < mctx->nbkref_ents; ++bkc_idx)
 	{
-	  Idx subexp_len;
+	  int subexp_len;
 	  re_dfastate_t *dest_state;
 	  struct re_backref_cache_entry *bkref_ent;
 	  bkref_ent = mctx->bkref_ents + bkc_idx;
@@ -2588,7 +2567,7 @@ transit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)
 	  dest_state = mctx->state_log[dest_str_idx];
 	  prev_nelem = ((mctx->state_log[cur_str_idx] == NULL) ? 0
 			: mctx->state_log[cur_str_idx]->nodes.nelem);
-	  /* Add 'new_dest_node' to state_log.  */
+	  /* Add `new_dest_node' to state_log.  */
 	  if (dest_state == NULL)
 	    {
 	      mctx->state_log[dest_str_idx]
@@ -2644,13 +2623,13 @@ transit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-get_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)
+get_subexp (re_match_context_t *mctx, int bkref_node, int bkref_str_idx)
 {
   const re_dfa_t *const dfa = mctx->dfa;
-  Idx subexp_num, sub_top_idx;
+  int subexp_num, sub_top_idx;
   const char *buf = (const char *) re_string_get_buffer (&mctx->input);
   /* Return if we have already checked BKREF_NODE at BKREF_STR_IDX.  */
-  Idx cache_idx = search_cur_bkref_entry (mctx, bkref_str_idx);
+  int cache_idx = search_cur_bkref_entry (mctx, bkref_str_idx);
   if (cache_idx != -1)
     {
       const struct re_backref_cache_entry *entry
@@ -2669,7 +2648,7 @@ get_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)
       reg_errcode_t err;
       re_sub_match_top_t *sub_top = mctx->sub_tops[sub_top_idx];
       re_sub_match_last_t *sub_last;
-      Idx sub_last_idx, sl_str, bkref_str_off;
+      int sub_last_idx, sl_str, bkref_str_off;
 
       if (dfa->nodes[sub_top->node].opr.idx != subexp_num)
 	continue; /* It isn't related.  */
@@ -2680,7 +2659,7 @@ get_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)
 	 evaluated.  */
       for (sub_last_idx = 0; sub_last_idx < sub_top->nlasts; ++sub_last_idx)
 	{
-	  regoff_t sl_str_diff;
+	  int sl_str_diff;
 	  sub_last = sub_top->lasts[sub_last_idx];
 	  sl_str_diff = sub_last->str_idx - sl_str;
 	  /* The matched string by the sub expression match with the substring
@@ -2726,8 +2705,7 @@ get_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)
       /* Then, search for the other last nodes of the sub expression.  */
       for (; sl_str <= bkref_str_idx; ++sl_str)
 	{
-	  Idx cls_node;
-	  regoff_t sl_str_off;
+	  int cls_node, sl_str_off;
 	  const re_node_set *nodes;
 	  sl_str_off = sl_str - sub_top->str_idx;
 	  /* The matched string by the sub expression match with the substring
@@ -2794,10 +2772,10 @@ get_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)
 
 static reg_errcode_t
 get_subexp_sub (re_match_context_t *mctx, const re_sub_match_top_t *sub_top,
-		re_sub_match_last_t *sub_last, Idx bkref_node, Idx bkref_str)
+		re_sub_match_last_t *sub_last, int bkref_node, int bkref_str)
 {
   reg_errcode_t err;
-  Idx to_idx;
+  int to_idx;
   /* Can the subexpression arrive the back reference?  */
   err = check_arrival (mctx, &sub_last->path, sub_last->node,
 		       sub_last->str_idx, bkref_node, bkref_str,
@@ -2820,14 +2798,14 @@ get_subexp_sub (re_match_context_t *mctx, const re_sub_match_top_t *sub_top,
 	 nodes.
 	 E.g. RE: (a){2}  */
 
-static Idx
+static int
 find_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,
-		  Idx subexp_idx, int type)
+		  int subexp_idx, int type)
 {
-  Idx cls_idx;
+  int cls_idx;
   for (cls_idx = 0; cls_idx < nodes->nelem; ++cls_idx)
     {
-      Idx cls_node = nodes->elems[cls_idx];
+      int cls_node = nodes->elems[cls_idx];
       const re_token_t *node = dfa->nodes + cls_node;
       if (node->type == type
 	  && node->opr.idx == subexp_idx)
@@ -2843,12 +2821,12 @@ find_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-check_arrival (re_match_context_t *mctx, state_array_t *path, Idx top_node,
-	       Idx top_str, Idx last_node, Idx last_str, int type)
+check_arrival (re_match_context_t *mctx, state_array_t *path, int top_node,
+	       int top_str, int last_node, int last_str, int type)
 {
   const re_dfa_t *const dfa = mctx->dfa;
   reg_errcode_t err = REG_NOERROR;
-  Idx subexp_num, backup_cur_idx, str_idx, null_cnt;
+  int subexp_num, backup_cur_idx, str_idx, null_cnt;
   re_dfastate_t *cur_state = NULL;
   re_node_set *cur_nodes, next_nodes;
   re_dfastate_t **backup_state_log;
@@ -2859,24 +2837,20 @@ check_arrival (re_match_context_t *mctx, state_array_t *path, Idx top_node,
   if (BE (path->alloc < last_str + mctx->max_mb_elem_len + 1, 0))
     {
       re_dfastate_t **new_array;
-      Idx old_alloc = path->alloc;
-      Idx incr_alloc = last_str + mctx->max_mb_elem_len + 1;
-      Idx new_alloc;
-      if (BE (IDX_MAX - old_alloc < incr_alloc, 0))
-	return REG_ESPACE;
-      new_alloc = old_alloc + incr_alloc;
-      if (BE (SIZE_MAX / sizeof (re_dfastate_t *) < new_alloc, 0))
-	return REG_ESPACE;
-      new_array = re_realloc (path->array, re_dfastate_t *, new_alloc);
+      int old_alloc = path->alloc;
+      path->alloc += last_str + mctx->max_mb_elem_len + 1;
+      new_array = re_realloc (path->array, re_dfastate_t *, path->alloc);
       if (BE (new_array == NULL, 0))
-	return REG_ESPACE;
+	{
+	  path->alloc = old_alloc;
+	  return REG_ESPACE;
+	}
       path->array = new_array;
-      path->alloc = new_alloc;
       memset (new_array + old_alloc, '\0',
 	      sizeof (re_dfastate_t *) * (path->alloc - old_alloc));
     }
 
-  str_idx = path->next_idx ? path->next_idx : top_str;
+  str_idx = path->next_idx ?: top_str;
 
   /* Temporary modify MCTX.  */
   backup_state_log = mctx->state_log;
@@ -3008,12 +2982,12 @@ check_arrival (re_match_context_t *mctx, state_array_t *path, Idx top_node,
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-check_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,
+check_arrival_add_next_nodes (re_match_context_t *mctx, int str_idx,
 			      re_node_set *cur_nodes, re_node_set *next_nodes)
 {
   const re_dfa_t *const dfa = mctx->dfa;
-  bool ok;
-  Idx cur_idx;
+  int result;
+  int cur_idx;
 #ifdef RE_ENABLE_I18N
   reg_errcode_t err = REG_NOERROR;
 #endif
@@ -3022,13 +2996,13 @@ check_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,
   for (cur_idx = 0; cur_idx < cur_nodes->nelem; ++cur_idx)
     {
       int naccepted = 0;
-      Idx cur_node = cur_nodes->elems[cur_idx];
+      int cur_node = cur_nodes->elems[cur_idx];
 #ifdef DEBUG
       re_token_type_t type = dfa->nodes[cur_node].type;
       assert (!IS_EPSILON_NODE (type));
 #endif
 #ifdef RE_ENABLE_I18N
-      /* If the node may accept "multi byte".  */
+      /* If the node may accept `multi byte'.  */
       if (dfa->nodes[cur_node].accept_mb)
 	{
 	  naccepted = check_node_accept_bytes (dfa, cur_node, &mctx->input,
@@ -3036,8 +3010,8 @@ check_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,
 	  if (naccepted > 1)
 	    {
 	      re_dfastate_t *dest_state;
-	      Idx next_node = dfa->nexts[cur_node];
-	      Idx next_idx = str_idx + naccepted;
+	      int next_node = dfa->nexts[cur_node];
+	      int next_idx = str_idx + naccepted;
 	      dest_state = mctx->state_log[next_idx];
 	      re_node_set_empty (&union_set);
 	      if (dest_state)
@@ -3049,8 +3023,8 @@ check_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,
 		      return err;
 		    }
 		}
-	      ok = re_node_set_insert (&union_set, next_node);
-	      if (BE (! ok, 0))
+	      result = re_node_set_insert (&union_set, next_node);
+	      if (BE (result < 0, 0))
 		{
 		  re_node_set_free (&union_set);
 		  return REG_ESPACE;
@@ -3069,8 +3043,8 @@ check_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,
       if (naccepted
 	  || check_node_accept (mctx, dfa->nodes + cur_node, str_idx))
 	{
-	  ok = re_node_set_insert (next_nodes, dfa->nexts[cur_node]);
-	  if (BE (! ok, 0))
+	  result = re_node_set_insert (next_nodes, dfa->nexts[cur_node]);
+	  if (BE (result < 0, 0))
 	    {
 	      re_node_set_free (&union_set);
 	      return REG_ESPACE;
@@ -3089,10 +3063,10 @@ check_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,
 
 static reg_errcode_t
 check_arrival_expand_ecl (const re_dfa_t *dfa, re_node_set *cur_nodes,
-			  Idx ex_subexp, int type)
+			  int ex_subexp, int type)
 {
   reg_errcode_t err;
-  Idx idx, outside_node;
+  int idx, outside_node;
   re_node_set new_nodes;
 #ifdef DEBUG
   assert (cur_nodes->nelem);
@@ -3105,7 +3079,7 @@ check_arrival_expand_ecl (const re_dfa_t *dfa, re_node_set *cur_nodes,
 
   for (idx = 0; idx < cur_nodes->nelem; ++idx)
     {
-      Idx cur_node = cur_nodes->elems[idx];
+      int cur_node = cur_nodes->elems[idx];
       const re_node_set *eclosure = dfa->eclosures + cur_node;
       outside_node = find_subexp_node (dfa, eclosure, ex_subexp, type);
       if (outside_node == -1)
@@ -3142,32 +3116,31 @@ check_arrival_expand_ecl (const re_dfa_t *dfa, re_node_set *cur_nodes,
 static reg_errcode_t
 __attribute_warn_unused_result__
 check_arrival_expand_ecl_sub (const re_dfa_t *dfa, re_node_set *dst_nodes,
-			      Idx target, Idx ex_subexp, int type)
+			      int target, int ex_subexp, int type)
 {
-  Idx cur_node;
+  int cur_node;
   for (cur_node = target; !re_node_set_contains (dst_nodes, cur_node);)
     {
-      bool ok;
+      int err;
 
       if (dfa->nodes[cur_node].type == type
 	  && dfa->nodes[cur_node].opr.idx == ex_subexp)
 	{
 	  if (type == OP_CLOSE_SUBEXP)
 	    {
-	      ok = re_node_set_insert (dst_nodes, cur_node);
-	      if (BE (! ok, 0))
+	      err = re_node_set_insert (dst_nodes, cur_node);
+	      if (BE (err == -1, 0))
 		return REG_ESPACE;
 	    }
 	  break;
 	}
-      ok = re_node_set_insert (dst_nodes, cur_node);
-      if (BE (! ok, 0))
+      err = re_node_set_insert (dst_nodes, cur_node);
+      if (BE (err == -1, 0))
 	return REG_ESPACE;
       if (dfa->edests[cur_node].nelem == 0)
 	break;
       if (dfa->edests[cur_node].nelem == 2)
 	{
-	  reg_errcode_t err;
 	  err = check_arrival_expand_ecl_sub (dfa, dst_nodes,
 					      dfa->edests[cur_node].elems[1],
 					      ex_subexp, type);
@@ -3187,11 +3160,11 @@ check_arrival_expand_ecl_sub (const re_dfa_t *dfa, re_node_set *dst_nodes,
 static reg_errcode_t
 __attribute_warn_unused_result__
 expand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,
-		    Idx cur_str, Idx subexp_num, int type)
+		    int cur_str, int subexp_num, int type)
 {
   const re_dfa_t *const dfa = mctx->dfa;
   reg_errcode_t err;
-  Idx cache_idx_start = search_cur_bkref_entry (mctx, cur_str);
+  int cache_idx_start = search_cur_bkref_entry (mctx, cur_str);
   struct re_backref_cache_entry *ent;
 
   if (cache_idx_start == -1)
@@ -3201,7 +3174,7 @@ expand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,
   ent = mctx->bkref_ents + cache_idx_start;
   do
     {
-      Idx to_idx, next_node;
+      int to_idx, next_node;
 
       /* Is this entry ENT is appropriate?  */
       if (!re_node_set_contains (cur_nodes, ent->node))
@@ -3239,14 +3212,14 @@ expand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,
 	  next_node = dfa->nexts[ent->node];
 	  if (mctx->state_log[to_idx])
 	    {
-	      bool ok;
+	      int ret;
 	      if (re_node_set_contains (&mctx->state_log[to_idx]->nodes,
 					next_node))
 		continue;
 	      err = re_node_set_init_copy (&union_set,
 					   &mctx->state_log[to_idx]->nodes);
-	      ok = re_node_set_insert (&union_set, next_node);
-	      if (BE (err != REG_NOERROR || ! ok, 0))
+	      ret = re_node_set_insert (&union_set, next_node);
+	      if (BE (err != REG_NOERROR || ret < 0, 0))
 		{
 		  re_node_set_free (&union_set);
 		  err = err != REG_NOERROR ? err : REG_ESPACE;
@@ -3271,19 +3244,17 @@ expand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,
 }
 
 /* Build transition table for the state.
-   Return true if successful.  */
+   Return 1 if succeeded, otherwise return NULL.  */
 
-static bool
+static int
 build_trtable (const re_dfa_t *dfa, re_dfastate_t *state)
 {
   reg_errcode_t err;
-  Idx i, j;
-  int ch;
-  bool need_word_trtable = false;
+  int i, j, ch, need_word_trtable = 0;
   bitset_word_t elem, mask;
   bool dests_node_malloced = false;
   bool dest_states_malloced = false;
-  Idx ndests; /* Number of the destination states from 'state'.  */
+  int ndests; /* Number of the destination states from `state'.  */
   re_dfastate_t **trtable;
   re_dfastate_t **dest_states = NULL, **dest_states_word, **dest_states_nl;
   re_node_set follows, *dests_node;
@@ -3297,8 +3268,8 @@ build_trtable (const re_dfa_t *dfa, re_dfastate_t *state)
   } *dests_alloc;
 
   /* We build DFA states which corresponds to the destination nodes
-     from 'state'.  'dests_node[i]' represents the nodes which i-th
-     destination state contains, and 'dests_ch[i]' represents the
+     from `state'.  `dests_node[i]' represents the nodes which i-th
+     destination state contains, and `dests_ch[i]' represents the
      characters which i-th destination state accepts.  */
   if (__libc_use_alloca (sizeof (struct dests_alloc)))
     dests_alloc = (struct dests_alloc *) alloca (sizeof (struct dests_alloc));
@@ -3306,32 +3277,32 @@ build_trtable (const re_dfa_t *dfa, re_dfastate_t *state)
     {
       dests_alloc = re_malloc (struct dests_alloc, 1);
       if (BE (dests_alloc == NULL, 0))
-	return false;
+	return 0;
       dests_node_malloced = true;
     }
   dests_node = dests_alloc->dests_node;
   dests_ch = dests_alloc->dests_ch;
 
-  /* Initialize transition table.  */
+  /* Initialize transiton table.  */
   state->word_trtable = state->trtable = NULL;
 
-  /* At first, group all nodes belonging to 'state' into several
+  /* At first, group all nodes belonging to `state' into several
      destinations.  */
   ndests = group_nodes_into_DFAstates (dfa, state, dests_node, dests_ch);
   if (BE (ndests <= 0, 0))
     {
       if (dests_node_malloced)
-	re_free (dests_alloc);
-      /* Return false in case of an error, true otherwise.  */
+	free (dests_alloc);
+      /* Return 0 in case of an error, 1 otherwise.  */
       if (ndests == 0)
 	{
 	  state->trtable = (re_dfastate_t **)
 	    calloc (sizeof (re_dfastate_t *), SBC_MAX);
-          if (BE (state->trtable == NULL, 0))
-            return false;
-	  return true;
+	  if (BE (state->trtable == NULL, 0))
+	    return 0;
+	  return 1;
 	}
-      return false;
+      return 0;
     }
 
   err = re_node_set_alloc (&follows, ndests + 1);
@@ -3351,18 +3322,19 @@ build_trtable (const re_dfa_t *dfa, re_dfastate_t *state)
       alloca (ndests * 3 * sizeof (re_dfastate_t *));
   else
     {
-      dest_states = re_malloc (re_dfastate_t *, ndests * 3);
+      dest_states = (re_dfastate_t **)
+	malloc (ndests * 3 * sizeof (re_dfastate_t *));
       if (BE (dest_states == NULL, 0))
 	{
 out_free:
 	  if (dest_states_malloced)
-	    re_free (dest_states);
+	    free (dest_states);
 	  re_node_set_free (&follows);
 	  for (i = 0; i < ndests; ++i)
 	    re_node_set_free (dests_node + i);
 	  if (dests_node_malloced)
-	    re_free (dests_alloc);
-	  return false;
+	    free (dests_alloc);
+	  return 0;
 	}
       dest_states_malloced = true;
     }
@@ -3373,7 +3345,7 @@ build_trtable (const re_dfa_t *dfa, re_dfastate_t *state)
   /* Then build the states for all destinations.  */
   for (i = 0; i < ndests; ++i)
     {
-      Idx next_node;
+      int next_node;
       re_node_set_empty (&follows);
       /* Merge the follows of this destination states.  */
       for (j = 0; j < dests_node[i].nelem; ++j)
@@ -3399,13 +3371,13 @@ build_trtable (const re_dfa_t *dfa, re_dfastate_t *state)
 	    goto out_free;
 
 	  if (dest_states[i] != dest_states_word[i] && dfa->mb_cur_max > 1)
-	    need_word_trtable = true;
+	    need_word_trtable = 1;
 
 	  dest_states_nl[i] = re_acquire_state_context (&err, dfa, &follows,
 							CONTEXT_NEWLINE);
 	  if (BE (dest_states_nl[i] == NULL && err != REG_NOERROR, 0))
 	    goto out_free;
-	}
+ 	}
       else
 	{
 	  dest_states_word[i] = dest_states[i];
@@ -3492,16 +3464,16 @@ build_trtable (const re_dfa_t *dfa, re_dfastate_t *state)
     }
 
   if (dest_states_malloced)
-    re_free (dest_states);
+    free (dest_states);
 
   re_node_set_free (&follows);
   for (i = 0; i < ndests; ++i)
     re_node_set_free (dests_node + i);
 
   if (dests_node_malloced)
-    re_free (dests_alloc);
+    free (dests_alloc);
 
-  return true;
+  return 1;
 }
 
 /* Group all nodes belonging to STATE into several destinations.
@@ -3509,20 +3481,20 @@ build_trtable (const re_dfa_t *dfa, re_dfastate_t *state)
    to DESTS_NODE[i] and set the characters accepted by the destination
    to DEST_CH[i].  This function return the number of destinations.  */
 
-static Idx
+static int
 group_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,
 			    re_node_set *dests_node, bitset_t *dests_ch)
 {
   reg_errcode_t err;
-  bool ok;
-  Idx i, j, k;
-  Idx ndests; /* Number of the destinations from 'state'.  */
+  int result;
+  int i, j, k;
+  int ndests; /* Number of the destinations from `state'.  */
   bitset_t accepts; /* Characters a node can accept.  */
   const re_node_set *cur_nodes = &state->nodes;
   bitset_empty (accepts);
   ndests = 0;
 
-  /* For all the nodes belonging to 'state',  */
+  /* For all the nodes belonging to `state',  */
   for (i = 0; i < cur_nodes->nelem; ++i)
     {
       re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];
@@ -3552,10 +3524,7 @@ group_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,
 #ifdef RE_ENABLE_I18N
       else if (type == OP_UTF8_PERIOD)
 	{
-	  if (ASCII_CHARS % BITSET_WORD_BITS == 0)
-	    memset (accepts, -1, ASCII_CHARS / CHAR_BIT);
-	  else
-	    bitset_merge (accepts, utf8_sb_map);
+	  memset (accepts, '\xff', sizeof (bitset_t) / 2);
 	  if (!(dfa->syntax & RE_DOT_NEWLINE))
 	    bitset_clear (accepts, '\n');
 	  if (dfa->syntax & RE_DOT_NOT_NULL)
@@ -3565,7 +3534,7 @@ group_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,
       else
 	continue;
 
-      /* Check the 'accepts' and sift the characters which are not
+      /* Check the `accepts' and sift the characters which are not
 	 match it the context.  */
       if (constraint)
 	{
@@ -3624,7 +3593,7 @@ group_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,
 	    }
 	}
 
-      /* Then divide 'accepts' into DFA states, or create a new
+      /* Then divide `accepts' into DFA states, or create a new
 	 state.  Above, we make sure that accepts is not empty.  */
       for (j = 0; j < ndests; ++j)
 	{
@@ -3637,7 +3606,7 @@ group_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,
 	  if (type == CHARACTER && !bitset_contain (dests_ch[j], node->opr.c))
 	    continue;
 
-	  /* Enumerate the intersection set of this state and 'accepts'.  */
+	  /* Enumerate the intersection set of this state and `accepts'.  */
 	  has_intersec = 0;
 	  for (k = 0; k < BITSET_WORDS; ++k)
 	    has_intersec |= intersec[k] = accepts[k] & dests_ch[j][k];
@@ -3645,7 +3614,7 @@ group_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,
 	  if (!has_intersec)
 	    continue;
 
-	  /* Then check if this state is a subset of 'accepts'.  */
+	  /* Then check if this state is a subset of `accepts'.  */
 	  not_subset = not_consumed = 0;
 	  for (k = 0; k < BITSET_WORDS; ++k)
 	    {
@@ -3653,8 +3622,8 @@ group_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,
 	      not_consumed |= accepts[k] = accepts[k] & ~dests_ch[j][k];
 	    }
 
-	  /* If this state isn't a subset of 'accepts', create a
-	     new group state, which has the 'remains'. */
+	  /* If this state isn't a subset of `accepts', create a
+	     new group state, which has the `remains'. */
 	  if (not_subset)
 	    {
 	      bitset_copy (dests_ch[ndests], remains);
@@ -3666,8 +3635,8 @@ group_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,
 	    }
 
 	  /* Put the position in the current group. */
-	  ok = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);
-	  if (BE (! ok, 0))
+	  result = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);
+	  if (BE (result < 0, 0))
 	    goto error_return;
 
 	  /* If all characters are consumed, go to next node. */
@@ -3693,7 +3662,7 @@ group_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,
 }
 
 #ifdef RE_ENABLE_I18N
-/* Check how many bytes the node 'dfa->nodes[node_idx]' accepts.
+/* Check how many bytes the node `dfa->nodes[node_idx]' accepts.
    Return the number of the bytes the node accepts.
    STR_IDX is the current index of the input string.
 
@@ -3706,12 +3675,12 @@ group_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,
 # endif
 
 static int
-check_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,
-			 const re_string_t *input, Idx str_idx)
+check_node_accept_bytes (const re_dfa_t *dfa, int node_idx,
+			 const re_string_t *input, int str_idx)
 {
   const re_token_t *node = dfa->nodes + node_idx;
   int char_len, elem_len;
-  Idx i;
+  int i;
 
   if (BE (node->type == OP_UTF8_PERIOD, 0))
     {
@@ -3790,7 +3759,7 @@ check_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,
 # ifdef _LIBC
       const unsigned char *pin
 	= ((const unsigned char *) re_string_get_buffer (input) + str_idx);
-      Idx j;
+      int j;
       uint32_t nrules;
 # endif /* _LIBC */
       int match_len = 0;
@@ -3858,7 +3827,6 @@ check_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,
 		in_collseq = find_collation_sequence_value (pin, elem_len);
 	    }
 	  /* match with range expression?  */
-	  /* FIXME: Implement rational ranges here, too.  */
 	  for (i = 0; i < cset->nranges; ++i)
 	    if (cset->range_starts[i] <= in_collseq
 		&& in_collseq <= cset->range_ends[i])
@@ -3888,7 +3856,7 @@ check_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,
 		    if (weight_len == weights[equiv_class_idx & 0xffffff]
 			&& (idx >> 24) == (equiv_class_idx >> 24))
 		      {
-			Idx cnt = 0;
+			int cnt = 0;
 
 			idx &= 0xffffff;
 			equiv_class_idx &= 0xffffff;
@@ -3910,9 +3878,18 @@ check_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,
 # endif /* _LIBC */
 	{
 	  /* match with range expression?  */
+#if __GNUC__ >= 2
+	  wchar_t cmp_buf[] = {L'\0', L'\0', wc, L'\0', L'\0', L'\0'};
+#else
+	  wchar_t cmp_buf[] = {L'\0', L'\0', L'\0', L'\0', L'\0', L'\0'};
+	  cmp_buf[2] = wc;
+#endif
 	  for (i = 0; i < cset->nranges; ++i)
 	    {
-	      if (cset->range_starts[i] <= wc && wc <= cset->range_ends[i])
+	      cmp_buf[0] = cset->range_starts[i];
+	      cmp_buf[4] = cset->range_ends[i];
+	      if (__wcscoll (cmp_buf, cmp_buf + 2) <= 0
+		  && __wcscoll (cmp_buf + 2, cmp_buf + 4) <= 0)
 		{
 		  match_len = char_len;
 		  goto check_node_accept_bytes_match;
@@ -3959,8 +3936,7 @@ find_collation_sequence_value (const unsigned char *mbs, size_t mbs_len)
 
       for (idx = 0; idx < extrasize;)
 	{
-	  int mbs_cnt;
-	  bool found = false;
+	  int mbs_cnt, found = 0;
 	  int32_t elem_mbs_len;
 	  /* Skip the name of collating element name.  */
 	  idx = idx + extra[idx] + 1;
@@ -3972,7 +3948,7 @@ find_collation_sequence_value (const unsigned char *mbs, size_t mbs_len)
 		  break;
 	      if (mbs_cnt == elem_mbs_len)
 		/* Found the entry.  */
-		found = true;
+		found = 1;
 	    }
 	  /* Skip the byte sequence of the collating element.  */
 	  idx += elem_mbs_len;
@@ -3997,9 +3973,9 @@ find_collation_sequence_value (const unsigned char *mbs, size_t mbs_len)
 /* Check whether the node accepts the byte which is IDX-th
    byte of the INPUT.  */
 
-static bool
+static int
 check_node_accept (const re_match_context_t *mctx, const re_token_t *node,
-		   Idx idx)
+		   int idx)
 {
   unsigned char ch;
   ch = re_string_byte_at (&mctx->input, idx);
@@ -4007,28 +3983,28 @@ check_node_accept (const re_match_context_t *mctx, const re_token_t *node,
     {
     case CHARACTER:
       if (node->opr.c != ch)
-        return false;
+	return 0;
       break;
 
     case SIMPLE_BRACKET:
       if (!bitset_contain (node->opr.sbcset, ch))
-        return false;
+	return 0;
       break;
 
 #ifdef RE_ENABLE_I18N
     case OP_UTF8_PERIOD:
-      if (ch >= ASCII_CHARS)
-        return false;
-      FALLTHROUGH;
+      if (ch >= 0x80)
+	return 0;
+      /* FALLTHROUGH */
 #endif
     case OP_PERIOD:
       if ((ch == '\n' && !(mctx->dfa->syntax & RE_DOT_NEWLINE))
 	  || (ch == '\0' && (mctx->dfa->syntax & RE_DOT_NOT_NULL)))
-	return false;
+	return 0;
       break;
 
     default:
-      return false;
+      return 0;
     }
 
   if (node->constraint)
@@ -4038,10 +4014,10 @@ check_node_accept (const re_match_context_t *mctx, const re_token_t *node,
       unsigned int context = re_string_context_at (&mctx->input, idx,
 						   mctx->eflags);
       if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))
-	return false;
+	return 0;
     }
 
-  return true;
+  return 1;
 }
 
 /* Extend the buffers, if the buffers have run out.  */
@@ -4054,11 +4030,10 @@ extend_buffers (re_match_context_t *mctx, int min_len)
   re_string_t *pstr = &mctx->input;
 
   /* Avoid overflow.  */
-  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) / 2
-          <= pstr->bufs_len, 0))
+  if (BE (INT_MAX / 2 / sizeof (re_dfastate_t *) <= pstr->bufs_len, 0))
     return REG_ESPACE;
 
-  /* Double the lengths of the buffers, but allocate at least MIN_LEN.  */
+  /* Double the lengthes of the buffers, but allocate at least MIN_LEN.  */
   ret = re_string_realloc_buffers (pstr,
 				   MAX (min_len,
 					MIN (pstr->len, pstr->bufs_len * 2)));
@@ -4114,19 +4089,12 @@ extend_buffers (re_match_context_t *mctx, int min_len)
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-match_ctx_init (re_match_context_t *mctx, int eflags, Idx n)
+match_ctx_init (re_match_context_t *mctx, int eflags, int n)
 {
   mctx->eflags = eflags;
   mctx->match_last = -1;
   if (n > 0)
     {
-      /* Avoid overflow.  */
-      size_t max_object_size =
-	MAX (sizeof (struct re_backref_cache_entry),
-	     sizeof (re_sub_match_top_t *));
-      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < n, 0))
-	return REG_ESPACE;
-
       mctx->bkref_ents = re_malloc (struct re_backref_cache_entry, n);
       mctx->sub_tops = re_malloc (re_sub_match_top_t *, n);
       if (BE (mctx->bkref_ents == NULL || mctx->sub_tops == NULL, 0))
@@ -4150,10 +4118,10 @@ match_ctx_init (re_match_context_t *mctx, int eflags, Idx n)
 static void
 match_ctx_clean (re_match_context_t *mctx)
 {
-  Idx st_idx;
+  int st_idx;
   for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)
     {
-      Idx sl_idx;
+      int sl_idx;
       re_sub_match_top_t *top = mctx->sub_tops[st_idx];
       for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)
 	{
@@ -4167,7 +4135,7 @@ match_ctx_clean (re_match_context_t *mctx)
 	  re_free (top->path->array);
 	  re_free (top->path);
 	}
-      re_free (top);
+      free (top);
     }
 
   mctx->nsub_tops = 0;
@@ -4192,8 +4160,8 @@ match_ctx_free (re_match_context_t *mctx)
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-match_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,
-		     Idx to)
+match_ctx_add_entry (re_match_context_t *mctx, int node, int str_idx, int from,
+		     int to)
 {
   if (mctx->nbkref_ents >= mctx->abkref_ents)
     {
@@ -4228,7 +4196,7 @@ match_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,
      A backreference does not epsilon-transition unless it is empty, so set
      to all zeros if FROM != TO.  */
   mctx->bkref_ents[mctx->nbkref_ents].eps_reachable_subexps_map
-    = (from == to ? -1 : 0);
+    = (from == to ? ~0 : 0);
 
   mctx->bkref_ents[mctx->nbkref_ents++].more = 0;
   if (mctx->max_mb_elem_len < to - from)
@@ -4236,13 +4204,13 @@ match_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,
   return REG_NOERROR;
 }
 
-/* Return the first entry with the same str_idx, or -1 if none is
+/* Search for the first entry which has the same str_idx, or -1 if none is
    found.  Note that MCTX->BKREF_ENTS is already sorted by MCTX->STR_IDX.  */
 
-static Idx
-search_cur_bkref_entry (const re_match_context_t *mctx, Idx str_idx)
+static int
+search_cur_bkref_entry (const re_match_context_t *mctx, int str_idx)
 {
-  Idx left, right, mid, last;
+  int left, right, mid, last;
   last = right = mctx->nbkref_ents;
   for (left = 0; left < right;)
     {
@@ -4263,7 +4231,7 @@ search_cur_bkref_entry (const re_match_context_t *mctx, Idx str_idx)
 
 static reg_errcode_t
 __attribute_warn_unused_result__
-match_ctx_add_subtop (re_match_context_t *mctx, Idx node, Idx str_idx)
+match_ctx_add_subtop (re_match_context_t *mctx, int node, int str_idx)
 {
 #ifdef DEBUG
   assert (mctx->sub_tops != NULL);
@@ -4271,7 +4239,7 @@ match_ctx_add_subtop (re_match_context_t *mctx, Idx node, Idx str_idx)
 #endif
   if (BE (mctx->nsub_tops == mctx->asub_tops, 0))
     {
-      Idx new_asub_tops = mctx->asub_tops * 2;
+      int new_asub_tops = mctx->asub_tops * 2;
       re_sub_match_top_t **new_array = re_realloc (mctx->sub_tops,
 						   re_sub_match_top_t *,
 						   new_asub_tops);
@@ -4292,12 +4260,12 @@ match_ctx_add_subtop (re_match_context_t *mctx, Idx node, Idx str_idx)
    at STR_IDX, whose corresponding OP_OPEN_SUBEXP is SUB_TOP.  */
 
 static re_sub_match_last_t *
-match_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)
+match_ctx_add_sublast (re_sub_match_top_t *subtop, int node, int str_idx)
 {
   re_sub_match_last_t *new_entry;
   if (BE (subtop->nlasts == subtop->alasts, 0))
     {
-      Idx new_alasts = 2 * subtop->alasts + 1;
+      int new_alasts = 2 * subtop->alasts + 1;
       re_sub_match_last_t **new_array = re_realloc (subtop->lasts,
 						    re_sub_match_last_t *,
 						    new_alasts);
@@ -4319,7 +4287,7 @@ match_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)
 
 static void
 sift_ctx_init (re_sift_context_t *sctx, re_dfastate_t **sifted_sts,
-	       re_dfastate_t **limited_sts, Idx last_node, Idx last_str_idx)
+	       re_dfastate_t **limited_sts, int last_node, int last_str_idx)
 {
   sctx->sifted_states = sifted_sts;
   sctx->limited_states = limited_sts;
diff --git a/release-notes-csl.xml b/release-notes-csl.xml
new file mode 100644
index 0000000000..1f6e730fff
--- /dev/null
+++ b/release-notes-csl.xml
@@ -0,0 +1,57 @@
+<!-- This file contains a series of release note fragments processed
+     by gnu-notes.  To add a note to it, use "gnu-notes -a
+     $release_config glibc".  The TARGET line should contain a
+     list of shell glob patterns for target names to which the note is
+     relevant; it may be removed if it is relevant to all targets.
+ -->
+
+      <!-- UUID: 8ee13c68-cc12-4068-8321-42d0daa9724b -->
+      <!-- TARGET: * -->
+      <!-- FEATURES: -->
+      <!-- COMPONENTS: glibc -->
+      <!-- SORT: glibc -->
+      <!-- ISSUE: ITS-152 -->
+      <formalpara>
+        <title><symbol>pthread_cleanup_push</symbol> compiler warnings</title>
+        <para>
+          Previously, use of the <symbol>pthread_cleanup_push</symbol> macro
+	  from <filename class='headerfile'>pthread.h</filename>
+	  sometimes caused warnings when compiled with optimization enabled.
+	  The macro has been modified to avoid those warnings.
+        </para>
+      </formalpara>
+
+      <!-- UUID: 9ec854c5-c6c1-4e55-b5b1-bdfe02bdf399 -->
+      <!-- TARGET: * -->
+      <!-- FEATURES: -->
+      <!-- COMPONENTS: glibc -->
+      <!-- SORT: glibc -->
+      <!-- ISSUE: CB-3023 -->
+      <formalpara>
+        <title><code>AF_BUS</code> support removed</title>
+        <para>
+          Support for the <code>AF_BUS</code> address family has been
+	  removed from the GNU C Library in this version of &csl_prod;.
+	  This extension was formerly provided for compliance with old
+	  versions of the GENIVI specification that are now obsolete.
+        </para>
+      </formalpara>
+
+      <!-- UUID: 2a636a21-b9cb-4318-b688-8267349bf66d -->
+      <!-- TARGET: * -->
+      <!-- FEATURES: -->
+      <!-- COMPONENTS: glibc -->
+      <!-- SORT: glibc -->
+      <!-- ISSUE: -->
+      <formalpara>
+        <title>GNU C Library version 2.27</title>
+        <para>
+	  &csl_prod; for &csl_target_name; now includes the GNU C
+	  Library version 2.27, git revision
+	  4a871574351e40d298d65949426a502c0ecaffcc.
+	  For more information about changes, see
+	  <uri>https://www.gnu.org/software/libc/</uri>.
+        </para>
+      </formalpara>
+
+<!-- Release notes end here.  -->
diff --git a/resolv/inet_addr.c b/resolv/inet_addr.c
index 32f58b0e13..022f7ea084 100644
--- a/resolv/inet_addr.c
+++ b/resolv/inet_addr.c
@@ -1,21 +1,3 @@
-/* Legacy IPv4 text-to-address functions.
-   Copyright (C) 2019 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
 /*
  * Copyright (c) 1983, 1990, 1993
  *    The Regents of the University of California.  All rights reserved.
@@ -96,97 +78,105 @@
 #include <limits.h>
 #include <errno.h>
 
-/* ASCII IPv4 Internet address interpretation routine.  The value
-   returned is in network order.  */
+/*
+ * Ascii internet address interpretation routine.
+ * The value returned is in network order.
+ */
 in_addr_t
-__inet_addr (const char *cp)
-{
-  struct in_addr val;
+__inet_addr(const char *cp) {
+	struct in_addr val;
 
-  if (__inet_aton (cp, &val))
-    return val.s_addr;
-  return INADDR_NONE;
+	if (__inet_aton(cp, &val))
+		return (val.s_addr);
+	return (INADDR_NONE);
 }
 weak_alias (__inet_addr, inet_addr)
 
-/* Check whether "cp" is a valid ASCII representation of an IPv4
-   Internet address and convert it to a binary address.  Returns 1 if
-   the address is valid, 0 if not.  This replaces inet_addr, the
-   return value from which cannot distinguish between failure and a
-   local broadcast address.  */
+/*
+ * Check whether "cp" is a valid ascii representation
+ * of an Internet address and convert to a binary address.
+ * Returns 1 if the address is valid, 0 if not.
+ * This replaces inet_addr, the return value from which
+ * cannot distinguish between failure and a local broadcast address.
+ */
 int
-__inet_aton (const char *cp, struct in_addr *addr)
+__inet_aton(const char *cp, struct in_addr *addr)
 {
-  static const in_addr_t max[4] = { 0xffffffff, 0xffffff, 0xffff, 0xff };
-  in_addr_t val;
-  char c;
-  union iaddr
-  {
-    uint8_t bytes[4];
-    uint32_t word;
-  } res;
-  uint8_t *pp = res.bytes;
-  int digit;
+	static const in_addr_t max[4] = { 0xffffffff, 0xffffff, 0xffff, 0xff };
+	in_addr_t val;
+	char c;
+	union iaddr {
+	  uint8_t bytes[4];
+	  uint32_t word;
+	} res;
+	uint8_t *pp = res.bytes;
+	int digit;
 
-  int saved_errno = errno;
-  __set_errno (0);
+	int saved_errno = errno;
+	__set_errno (0);
 
-  res.word = 0;
+	res.word = 0;
 
-  c = *cp;
-  for (;;)
-    {
-      /* Collect number up to ``.''.  Values are specified as for C:
-	 0x=hex, 0=octal, isdigit=decimal.  */
-      if (!isdigit (c))
-	goto ret_0;
-      {
-	char *endp;
-	unsigned long ul = strtoul (cp, &endp, 0);
-	if (ul == ULONG_MAX && errno == ERANGE)
-	  goto ret_0;
-	if (ul > 0xfffffffful)
-	  goto ret_0;
-	val = ul;
-	digit = cp != endp;
-	cp = endp;
-      }
-      c = *cp;
-      if (c == '.')
-	{
-	  /* Internet format:
-	     a.b.c.d
-	     a.b.c	(with c treated as 16 bits)
-	     a.b	(with b treated as 24 bits).  */
-	  if (pp > res.bytes + 2 || val > 0xff)
-	    goto ret_0;
-	  *pp++ = val;
-	  c = *++cp;
+	c = *cp;
+	for (;;) {
+		/*
+		 * Collect number up to ``.''.
+		 * Values are specified as for C:
+		 * 0x=hex, 0=octal, isdigit=decimal.
+		 */
+		if (!isdigit(c))
+			goto ret_0;
+		{
+			char *endp;
+			unsigned long ul = strtoul (cp, (char **) &endp, 0);
+			if (ul == ULONG_MAX && errno == ERANGE)
+				goto ret_0;
+			if (ul > 0xfffffffful)
+				goto ret_0;
+			val = ul;
+			digit = cp != endp;
+			cp = endp;
+		}
+		c = *cp;
+		if (c == '.') {
+			/*
+			 * Internet format:
+			 *	a.b.c.d
+			 *	a.b.c	(with c treated as 16 bits)
+			 *	a.b	(with b treated as 24 bits)
+			 */
+			if (pp > res.bytes + 2 || val > 0xff)
+				goto ret_0;
+			*pp++ = val;
+			c = *++cp;
+		} else
+			break;
 	}
-      else
-	break;
-    }
-  /* Check for trailing characters.  */
-  if (c != '\0' && (!isascii (c) || !isspace (c)))
-    goto ret_0;
-  /*  Did we get a valid digit?  */
-  if (!digit)
-    goto ret_0;
+	/*
+	 * Check for trailing characters.
+	 */
+	if (c != '\0' && (!isascii(c) || !isspace(c)))
+		goto ret_0;
+	/*
+	 * Did we get a valid digit?
+	 */
+	if (!digit)
+		goto ret_0;
 
-  /* Check whether the last part is in its limits depending on the
-     number of parts in total.  */
-  if (val > max[pp - res.bytes])
-    goto ret_0;
+	/* Check whether the last part is in its limits depending on
+	   the number of parts in total.  */
+	if (val > max[pp - res.bytes])
+	  goto ret_0;
 
-  if (addr != NULL)
-    addr->s_addr = res.word | htonl (val);
+	if (addr != NULL)
+		addr->s_addr = res.word | htonl (val);
 
-  __set_errno (saved_errno);
-  return 1;
+	__set_errno (saved_errno);
+	return (1);
 
- ret_0:
-  __set_errno (saved_errno);
-  return 0;
+ret_0:
+	__set_errno (saved_errno);
+	return (0);
 }
 weak_alias (__inet_aton, inet_aton)
 libc_hidden_def (__inet_aton)
diff --git a/resolv/nss_dns/dns-host.c b/resolv/nss_dns/dns-host.c
index 99c3b61e1c..5dc2829cd1 100644
--- a/resolv/nss_dns/dns-host.c
+++ b/resolv/nss_dns/dns-host.c
@@ -274,26 +274,11 @@ gethostbyname3_context (struct resolv_context *ctx,
   return status;
 }
 
-/* Verify that the name looks like a host name.  There is no point in
-   sending a query which will not produce a usable name in the
-   response.  */
-static enum nss_status
-check_name (const char *name, int *h_errnop)
-{
-  if (res_hnok (name))
-    return NSS_STATUS_SUCCESS;
-  *h_errnop = HOST_NOT_FOUND;
-  return NSS_STATUS_NOTFOUND;
-}
-
 enum nss_status
 _nss_dns_gethostbyname2_r (const char *name, int af, struct hostent *result,
 			   char *buffer, size_t buflen, int *errnop,
 			   int *h_errnop)
 {
-  enum nss_status status = check_name (name, h_errnop);
-  if (status != NSS_STATUS_SUCCESS)
-    return status;
   return _nss_dns_gethostbyname3_r (name, af, result, buffer, buflen, errnop,
 				    h_errnop, NULL, NULL);
 }
@@ -304,9 +289,6 @@ _nss_dns_gethostbyname_r (const char *name, struct hostent *result,
 			  char *buffer, size_t buflen, int *errnop,
 			  int *h_errnop)
 {
-  enum nss_status status = check_name (name, h_errnop);
-  if (status != NSS_STATUS_SUCCESS)
-    return status;
   struct resolv_context *ctx = __resolv_context_get ();
   if (ctx == NULL)
     {
@@ -314,7 +296,7 @@ _nss_dns_gethostbyname_r (const char *name, struct hostent *result,
       *h_errnop = NETDB_INTERNAL;
       return NSS_STATUS_UNAVAIL;
     }
-  status = NSS_STATUS_NOTFOUND;
+  enum nss_status status = NSS_STATUS_NOTFOUND;
   if (res_use_inet6 ())
     status = gethostbyname3_context (ctx, name, AF_INET6, result, buffer,
 				     buflen, errnop, h_errnop, NULL, NULL);
@@ -331,9 +313,6 @@ _nss_dns_gethostbyname4_r (const char *name, struct gaih_addrtuple **pat,
 			   char *buffer, size_t buflen, int *errnop,
 			   int *herrnop, int32_t *ttlp)
 {
-  enum nss_status status = check_name (name, herrnop);
-  if (status != NSS_STATUS_SUCCESS)
-    return status;
   struct resolv_context *ctx = __resolv_context_get ();
   if (ctx == NULL)
     {
@@ -368,6 +347,7 @@ _nss_dns_gethostbyname4_r (const char *name, struct gaih_addrtuple **pat,
   int ans2p_malloced = 0;
 
   int olderr = errno;
+  enum nss_status status;
   int n = __res_context_search (ctx, name, C_IN, T_QUERY_A_AND_AAAA,
 				host_buffer.buf->buf, 2048, &host_buffer.ptr,
 				&ans2p, &nans2p, &resplen2, &ans2p_malloced);
diff --git a/sysdeps/arm/armv7/multiarch/memcpy_impl.S b/sysdeps/arm/armv7/multiarch/memcpy_impl.S
index 802c310f3e..2de172635c 100644
--- a/sysdeps/arm/armv7/multiarch/memcpy_impl.S
+++ b/sysdeps/arm/armv7/multiarch/memcpy_impl.S
@@ -268,7 +268,7 @@ ENTRY(memcpy)
 
 	mov	dst, dstin	/* Preserve dstin, we need to return it.  */
 	cmp	count, #64
-	bhs	.Lcpy_not_short
+	bge	.Lcpy_not_short
 	/* Deal with small copies quickly by dropping straight into the
 	   exit block.  */
 
@@ -351,10 +351,10 @@ ENTRY(memcpy)
 
 1:
 	subs	tmp2, count, #64	/* Use tmp2 for count.  */
-	blo	.Ltail63aligned
+	blt	.Ltail63aligned
 
 	cmp	tmp2, #512
-	bhs	.Lcpy_body_long
+	bge	.Lcpy_body_long
 
 .Lcpy_body_medium:			/* Count in tmp2.  */
 #ifdef USE_VFP
@@ -378,7 +378,7 @@ ENTRY(memcpy)
 	add	src, src, #64
 	vstr	d1, [dst, #56]
 	add	dst, dst, #64
-	bhs	1b
+	bge	1b
 	tst	tmp2, #0x3f
 	beq	.Ldone
 
@@ -412,7 +412,7 @@ ENTRY(memcpy)
 	ldrd	A_l, A_h, [src, #64]!
 	strd	A_l, A_h, [dst, #64]!
 	subs	tmp2, tmp2, #64
-	bhs	1b
+	bge	1b
 	tst	tmp2, #0x3f
 	bne	1f
 	ldr	tmp2,[sp], #FRAME_SIZE
@@ -482,7 +482,7 @@ ENTRY(memcpy)
 	add	src, src, #32
 
 	subs	tmp2, tmp2, #prefetch_lines * 64 * 2
-	blo	2f
+	blt	2f
 1:
 	cpy_line_vfp	d3, 0
 	cpy_line_vfp	d4, 64
@@ -494,7 +494,7 @@ ENTRY(memcpy)
 	add	dst, dst, #2 * 64
 	add	src, src, #2 * 64
 	subs	tmp2, tmp2, #prefetch_lines * 64
-	bhs	1b
+	bge	1b
 
 2:
 	cpy_tail_vfp	d3, 0
@@ -615,8 +615,8 @@ ENTRY(memcpy)
 1:
 	pld	[src, #(3 * 64)]
 	subs	count, count, #64
-	ldrlo	tmp2, [sp], #FRAME_SIZE
-	blo	.Ltail63unaligned
+	ldrmi	tmp2, [sp], #FRAME_SIZE
+	bmi	.Ltail63unaligned
 	pld	[src, #(4 * 64)]
 
 #ifdef USE_NEON
@@ -633,7 +633,7 @@ ENTRY(memcpy)
 	neon_load_multi d0-d3, src
 	neon_load_multi d4-d7, src
 	subs	count, count, #64
-	blo	2f
+	bmi	2f
 1:
 	pld	[src, #(4 * 64)]
 	neon_store_multi d0-d3, dst
@@ -641,7 +641,7 @@ ENTRY(memcpy)
 	neon_store_multi d4-d7, dst
 	neon_load_multi d4-d7, src
 	subs	count, count, #64
-	bhs	1b
+	bpl	1b
 2:
 	neon_store_multi d0-d3, dst
 	neon_store_multi d4-d7, dst
diff --git a/sysdeps/arm/memcpy.S b/sysdeps/arm/memcpy.S
index 7b4214aae9..cba8609813 100644
--- a/sysdeps/arm/memcpy.S
+++ b/sysdeps/arm/memcpy.S
@@ -68,7 +68,7 @@ ENTRY(memcpy)
 		cfi_remember_state
 
 		subs	r2, r2, #4
-		blo	8f
+		blt	8f
 		ands	ip, r0, #3
 	PLD(	pld	[r1, #0]		)
 		bne	9f
@@ -82,7 +82,7 @@ ENTRY(memcpy)
 		cfi_rel_offset (r6, 4)
 		cfi_rel_offset (r7, 8)
 		cfi_rel_offset (r8, 12)
-		blo	5f
+		blt	5f
 
 	CALGN(	ands	ip, r1, #31		)
 	CALGN(	rsb	r3, ip, #32		)
@@ -98,9 +98,9 @@ ENTRY(memcpy)
 #endif
 
 	PLD(	pld	[r1, #0]		)
-2:	PLD(	cmp	r2, #96			)
+2:	PLD(	subs	r2, r2, #96		)
 	PLD(	pld	[r1, #28]		)
-	PLD(	blo	4f			)
+	PLD(	blt	4f			)
 	PLD(	pld	[r1, #60]		)
 	PLD(	pld	[r1, #92]		)
 
@@ -108,7 +108,9 @@ ENTRY(memcpy)
 4:		ldmia	r1!, {r3, r4, r5, r6, r7, r8, ip, lr}
 		subs	r2, r2, #32
 		stmia	r0!, {r3, r4, r5, r6, r7, r8, ip, lr}
-		bhs	3b
+		bge	3b
+	PLD(	cmn	r2, #96			)
+	PLD(	bge	4b			)
 
 5:		ands	ip, r2, #28
 		rsb	ip, ip, #32
@@ -220,7 +222,7 @@ ENTRY(memcpy)
 		strbge	r4, [r0], #1
 		subs	r2, r2, ip
 		strb	lr, [r0], #1
-		blo	8b
+		blt	8b
 		ands	ip, r1, #3
 		beq	1b
 
@@ -234,7 +236,7 @@ ENTRY(memcpy)
 		.macro	forward_copy_shift pull push
 
 		subs	r2, r2, #28
-		blo	14f
+		blt	14f
 
 	CALGN(	ands	ip, r1, #31		)
 	CALGN(	rsb	ip, ip, #32		)
@@ -251,9 +253,9 @@ ENTRY(memcpy)
 		cfi_rel_offset (r10, 16)
 
 	PLD(	pld	[r1, #0]		)
-	PLD(	cmp	r2, #96			)
+	PLD(	subs	r2, r2, #96		)
 	PLD(	pld	[r1, #28]		)
-	PLD(	blo	13f			)
+	PLD(	blt	13f			)
 	PLD(	pld	[r1, #60]		)
 	PLD(	pld	[r1, #92]		)
 
@@ -278,7 +280,9 @@ ENTRY(memcpy)
 		mov	ip, ip, PULL #\pull
 		orr	ip, ip, lr, PUSH #\push
 		stmia	r0!, {r3, r4, r5, r6, r7, r8, r10, ip}
-		bhs	12b
+		bge	12b
+	PLD(	cmn	r2, #96			)
+	PLD(	bge	13b			)
 
 		pop	{r5 - r8, r10}
 		cfi_adjust_cfa_offset (-20)
diff --git a/sysdeps/arm/memmove.S b/sysdeps/arm/memmove.S
index b28a811912..74d3042043 100644
--- a/sysdeps/arm/memmove.S
+++ b/sysdeps/arm/memmove.S
@@ -85,7 +85,7 @@ ENTRY(memmove)
 		add	r1, r1, r2
 		add	r0, r0, r2
 		subs	r2, r2, #4
-		blo	8f
+		blt	8f
 		ands	ip, r0, #3
 	PLD(	pld	[r1, #-4]		)
 		bne	9f
@@ -99,7 +99,7 @@ ENTRY(memmove)
 		cfi_rel_offset (r6, 4)
 		cfi_rel_offset (r7, 8)
 		cfi_rel_offset (r8, 12)
-		blo     5f
+		blt	5f
 
 	CALGN(	ands	ip, r1, #31		)
 	CALGN(	sbcsne	r4, ip, r2		)  @ C is always set here
@@ -114,9 +114,9 @@ ENTRY(memmove)
 #endif
 
 	PLD(	pld	[r1, #-4]		)
-2:	PLD(	cmp	r2, #96			)
+2:	PLD(	subs	r2, r2, #96		)
 	PLD(	pld	[r1, #-32]		)
-	PLD(    blo     4f                      )
+	PLD(	blt	4f			)
 	PLD(	pld	[r1, #-64]		)
 	PLD(	pld	[r1, #-96]		)
 
@@ -124,7 +124,9 @@ ENTRY(memmove)
 4:		ldmdb	r1!, {r3, r4, r5, r6, r7, r8, ip, lr}
 		subs	r2, r2, #32
 		stmdb	r0!, {r3, r4, r5, r6, r7, r8, ip, lr}
-		bhs     3b
+		bge	3b
+	PLD(	cmn	r2, #96			)
+	PLD(	bge	4b			)
 
 5:		ands	ip, r2, #28
 		rsb	ip, ip, #32
@@ -235,7 +237,7 @@ ENTRY(memmove)
 		strbge	r4, [r0, #-1]!
 		subs	r2, r2, ip
 		strb	lr, [r0, #-1]!
-		blo	8b
+		blt	8b
 		ands	ip, r1, #3
 		beq	1b
 
@@ -249,7 +251,7 @@ ENTRY(memmove)
 		.macro	backward_copy_shift push pull
 
 		subs	r2, r2, #28
-		blo	14f
+		blt	14f
 
 	CALGN(	ands	ip, r1, #31		)
 	CALGN(	rsb	ip, ip, #32		)
@@ -266,9 +268,9 @@ ENTRY(memmove)
 		cfi_rel_offset (r10, 16)
 
 	PLD(	pld	[r1, #-4]		)
-	PLD(	cmp	r2, #96			)
+	PLD(	subs	r2, r2, #96		)
 	PLD(	pld	[r1, #-32]		)
-	PLD(	blo	13f			)
+	PLD(	blt	13f			)
 	PLD(	pld	[r1, #-64]		)
 	PLD(	pld	[r1, #-96]		)
 
@@ -293,7 +295,9 @@ ENTRY(memmove)
 		mov     r4, r4, PUSH #\push
 		orr     r4, r4, r3, PULL #\pull
 		stmdb   r0!, {r4 - r8, r10, ip, lr}
-		bhs	12b
+		bge	12b
+	PLD(	cmn	r2, #96			)
+	PLD(	bge	13b			)
 
 		pop	{r5 - r8, r10}
 		cfi_adjust_cfa_offset (-20)
diff --git a/sysdeps/ieee754/ldbl-96/Makefile b/sysdeps/ieee754/ldbl-96/Makefile
index daa2753cf1..790f670e44 100644
--- a/sysdeps/ieee754/ldbl-96/Makefile
+++ b/sysdeps/ieee754/ldbl-96/Makefile
@@ -17,8 +17,5 @@
 # <http://www.gnu.org/licenses/>.
 
 ifeq ($(subdir),math)
-tests += test-canonical-ldbl-96 test-totalorderl-ldbl-96 test-sinl-pseudo
-ifeq ($(have-ssp),yes)
-CFLAGS-test-sinl-pseudo.c += -fstack-protector-all
+tests += test-canonical-ldbl-96 test-totalorderl-ldbl-96
 endif
-endif # $(subdir) == math
diff --git a/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c b/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c
index c2ee56e71f..f67805f2d3 100644
--- a/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c
+++ b/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c
@@ -210,18 +210,6 @@ __ieee754_rem_pio2l (long double x, long double *y)
       return 0;
     }
 
-  if ((i0 & 0x80000000) == 0)
-    {
-      /* Pseudo-zero and unnormal representations are not valid
-	 representations of long double.  We need to avoid stack
-	 corruption in __kernel_rem_pio2, which expects input in a
-	 particular normal form, but those representations do not need
-	 to be consistently handled like any particular floating-point
-	 value.  */
-      y[1] = y[0] = __builtin_nanl ("");
-      return 0;
-    }
-
   /* Split the 64 bits of the mantissa into three 24-bit integers
      stored in a double array.  */
   exp = j0 - 23;
diff --git a/sysdeps/ieee754/ldbl-96/test-sinl-pseudo.c b/sysdeps/ieee754/ldbl-96/test-sinl-pseudo.c
deleted file mode 100644
index f59b97769d..0000000000
--- a/sysdeps/ieee754/ldbl-96/test-sinl-pseudo.c
+++ /dev/null
@@ -1,41 +0,0 @@
-/* Test sinl for pseudo-zeros and unnormals for ldbl-96 (bug 25487).
-   Copyright (C) 2020 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <math.h>
-#include <math_ldbl.h>
-#include <stdint.h>
-
-static int
-do_test (void)
-{
-  for (int i = 0; i < 64; i++)
-    {
-      uint64_t sig = i == 63 ? 0 : 1ULL << i;
-      long double ld;
-      SET_LDOUBLE_WORDS (ld, 0x4141,
-			 sig >> 32, sig & 0xffffffffULL);
-      /* The requirement is that no stack overflow occurs when the
-	 pseudo-zero or unnormal goes through range reduction.  */
-      volatile long double ldr;
-      ldr = sinl (ld);
-      (void) ldr;
-    }
-  return 0;
-}
-
-#include <support/test-driver.c>
diff --git a/sysdeps/unix/sysv/linux/if_index.c b/sysdeps/unix/sysv/linux/if_index.c
index 782fc5e175..e3d08982d9 100644
--- a/sysdeps/unix/sysv/linux/if_index.c
+++ b/sysdeps/unix/sysv/linux/if_index.c
@@ -38,6 +38,11 @@ __if_nametoindex (const char *ifname)
   return 0;
 #else
   struct ifreq ifr;
+  int fd = __opensock ();
+
+  if (fd < 0)
+    return 0;
+
   if (strlen (ifname) >= IFNAMSIZ)
     {
       __set_errno (ENODEV);
@@ -45,12 +50,6 @@ __if_nametoindex (const char *ifname)
     }
 
   strncpy (ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
-
-  int fd = __opensock ();
-
-  if (fd < 0)
-    return 0;
-
   if (__ioctl (fd, SIOCGIFINDEX, &ifr) < 0)
     {
       int saved_errno = errno;
