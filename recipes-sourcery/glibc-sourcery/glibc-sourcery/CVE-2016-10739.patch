From 29e3856910dbdb4cffec5aa1fc9741aed6afb34e Mon Sep 17 00:00:00 2001
From: Florian Weimer <fweimer@redhat.com>
Date: Mon, 21 Jan 2019 08:59:42 +0100
Subject: [PATCH 2/7] Fix CVE-2016-10739

Two commits were applied here:

- resolv: Reformat inet_addr, inet_aton to GNU style
- resolv: Do not send queries for non-host-names in nss_dns [BZ #24112]

(cherry picked from commit 5e30b8ef0758763effa115634e0ed7d8938e4bc0)
(cherry picked from commit 6ca53a2453598804a2559a548a08424fca96434a)

CVE: CVE-2016-10739
Signed-off-by: Christopher Larson <chris_larson@mentor.com>
---
 ChangeLog                 |  14 +++
 resolv/inet_addr.c        | 178 ++++++++++++++++++++------------------
 resolv/nss_dns/dns-host.c |  24 ++++-
 3 files changed, 130 insertions(+), 86 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index 4ee2c93258..0f018d7f4e 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,17 @@
+2019-01-18  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #24112]
+	resolv: Do not send queries for non-host-names in nss_dns.
+	* resolv/nss_dns/dns-host.c (check_name): New function.
+	(_nss_dns_gethostbyname2_r): Use it.
+	(_nss_dns_gethostbyname_r): Likewise.
+	(_nss_dns_gethostbyname4_r): Likewise.
+
+2019-01-21  Florian Weimer  <fweimer@redhat.com>
+
+	* resolv/inet_addr.c: Reformat to GNU style.
+	(__inet_addr, __inet_aton): Update comment.
+
 2018-07-04  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
 
 	[BZ #23233]
diff --git a/resolv/inet_addr.c b/resolv/inet_addr.c
index 022f7ea084..32f58b0e13 100644
--- a/resolv/inet_addr.c
+++ b/resolv/inet_addr.c
@@ -1,3 +1,21 @@
+/* Legacy IPv4 text-to-address functions.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
 /*
  * Copyright (c) 1983, 1990, 1993
  *    The Regents of the University of California.  All rights reserved.
@@ -78,105 +96,97 @@
 #include <limits.h>
 #include <errno.h>
 
-/*
- * Ascii internet address interpretation routine.
- * The value returned is in network order.
- */
+/* ASCII IPv4 Internet address interpretation routine.  The value
+   returned is in network order.  */
 in_addr_t
-__inet_addr(const char *cp) {
-	struct in_addr val;
+__inet_addr (const char *cp)
+{
+  struct in_addr val;
 
-	if (__inet_aton(cp, &val))
-		return (val.s_addr);
-	return (INADDR_NONE);
+  if (__inet_aton (cp, &val))
+    return val.s_addr;
+  return INADDR_NONE;
 }
 weak_alias (__inet_addr, inet_addr)
 
-/*
- * Check whether "cp" is a valid ascii representation
- * of an Internet address and convert to a binary address.
- * Returns 1 if the address is valid, 0 if not.
- * This replaces inet_addr, the return value from which
- * cannot distinguish between failure and a local broadcast address.
- */
+/* Check whether "cp" is a valid ASCII representation of an IPv4
+   Internet address and convert it to a binary address.  Returns 1 if
+   the address is valid, 0 if not.  This replaces inet_addr, the
+   return value from which cannot distinguish between failure and a
+   local broadcast address.  */
 int
-__inet_aton(const char *cp, struct in_addr *addr)
+__inet_aton (const char *cp, struct in_addr *addr)
 {
-	static const in_addr_t max[4] = { 0xffffffff, 0xffffff, 0xffff, 0xff };
-	in_addr_t val;
-	char c;
-	union iaddr {
-	  uint8_t bytes[4];
-	  uint32_t word;
-	} res;
-	uint8_t *pp = res.bytes;
-	int digit;
+  static const in_addr_t max[4] = { 0xffffffff, 0xffffff, 0xffff, 0xff };
+  in_addr_t val;
+  char c;
+  union iaddr
+  {
+    uint8_t bytes[4];
+    uint32_t word;
+  } res;
+  uint8_t *pp = res.bytes;
+  int digit;
 
-	int saved_errno = errno;
-	__set_errno (0);
+  int saved_errno = errno;
+  __set_errno (0);
 
-	res.word = 0;
+  res.word = 0;
 
-	c = *cp;
-	for (;;) {
-		/*
-		 * Collect number up to ``.''.
-		 * Values are specified as for C:
-		 * 0x=hex, 0=octal, isdigit=decimal.
-		 */
-		if (!isdigit(c))
-			goto ret_0;
-		{
-			char *endp;
-			unsigned long ul = strtoul (cp, (char **) &endp, 0);
-			if (ul == ULONG_MAX && errno == ERANGE)
-				goto ret_0;
-			if (ul > 0xfffffffful)
-				goto ret_0;
-			val = ul;
-			digit = cp != endp;
-			cp = endp;
-		}
-		c = *cp;
-		if (c == '.') {
-			/*
-			 * Internet format:
-			 *	a.b.c.d
-			 *	a.b.c	(with c treated as 16 bits)
-			 *	a.b	(with b treated as 24 bits)
-			 */
-			if (pp > res.bytes + 2 || val > 0xff)
-				goto ret_0;
-			*pp++ = val;
-			c = *++cp;
-		} else
-			break;
+  c = *cp;
+  for (;;)
+    {
+      /* Collect number up to ``.''.  Values are specified as for C:
+	 0x=hex, 0=octal, isdigit=decimal.  */
+      if (!isdigit (c))
+	goto ret_0;
+      {
+	char *endp;
+	unsigned long ul = strtoul (cp, &endp, 0);
+	if (ul == ULONG_MAX && errno == ERANGE)
+	  goto ret_0;
+	if (ul > 0xfffffffful)
+	  goto ret_0;
+	val = ul;
+	digit = cp != endp;
+	cp = endp;
+      }
+      c = *cp;
+      if (c == '.')
+	{
+	  /* Internet format:
+	     a.b.c.d
+	     a.b.c	(with c treated as 16 bits)
+	     a.b	(with b treated as 24 bits).  */
+	  if (pp > res.bytes + 2 || val > 0xff)
+	    goto ret_0;
+	  *pp++ = val;
+	  c = *++cp;
 	}
-	/*
-	 * Check for trailing characters.
-	 */
-	if (c != '\0' && (!isascii(c) || !isspace(c)))
-		goto ret_0;
-	/*
-	 * Did we get a valid digit?
-	 */
-	if (!digit)
-		goto ret_0;
+      else
+	break;
+    }
+  /* Check for trailing characters.  */
+  if (c != '\0' && (!isascii (c) || !isspace (c)))
+    goto ret_0;
+  /*  Did we get a valid digit?  */
+  if (!digit)
+    goto ret_0;
 
-	/* Check whether the last part is in its limits depending on
-	   the number of parts in total.  */
-	if (val > max[pp - res.bytes])
-	  goto ret_0;
+  /* Check whether the last part is in its limits depending on the
+     number of parts in total.  */
+  if (val > max[pp - res.bytes])
+    goto ret_0;
 
-	if (addr != NULL)
-		addr->s_addr = res.word | htonl (val);
+  if (addr != NULL)
+    addr->s_addr = res.word | htonl (val);
 
-	__set_errno (saved_errno);
-	return (1);
+  __set_errno (saved_errno);
+  return 1;
 
-ret_0:
-	__set_errno (saved_errno);
-	return (0);
+ ret_0:
+  __set_errno (saved_errno);
+  return 0;
 }
 weak_alias (__inet_aton, inet_aton)
 libc_hidden_def (__inet_aton)
diff --git a/resolv/nss_dns/dns-host.c b/resolv/nss_dns/dns-host.c
index 5dc2829cd1..99c3b61e1c 100644
--- a/resolv/nss_dns/dns-host.c
+++ b/resolv/nss_dns/dns-host.c
@@ -274,11 +274,26 @@ gethostbyname3_context (struct resolv_context *ctx,
   return status;
 }
 
+/* Verify that the name looks like a host name.  There is no point in
+   sending a query which will not produce a usable name in the
+   response.  */
+static enum nss_status
+check_name (const char *name, int *h_errnop)
+{
+  if (res_hnok (name))
+    return NSS_STATUS_SUCCESS;
+  *h_errnop = HOST_NOT_FOUND;
+  return NSS_STATUS_NOTFOUND;
+}
+
 enum nss_status
 _nss_dns_gethostbyname2_r (const char *name, int af, struct hostent *result,
 			   char *buffer, size_t buflen, int *errnop,
 			   int *h_errnop)
 {
+  enum nss_status status = check_name (name, h_errnop);
+  if (status != NSS_STATUS_SUCCESS)
+    return status;
   return _nss_dns_gethostbyname3_r (name, af, result, buffer, buflen, errnop,
 				    h_errnop, NULL, NULL);
 }
@@ -289,6 +304,9 @@ _nss_dns_gethostbyname_r (const char *name, struct hostent *result,
 			  char *buffer, size_t buflen, int *errnop,
 			  int *h_errnop)
 {
+  enum nss_status status = check_name (name, h_errnop);
+  if (status != NSS_STATUS_SUCCESS)
+    return status;
   struct resolv_context *ctx = __resolv_context_get ();
   if (ctx == NULL)
     {
@@ -296,7 +314,7 @@ _nss_dns_gethostbyname_r (const char *name, struct hostent *result,
       *h_errnop = NETDB_INTERNAL;
       return NSS_STATUS_UNAVAIL;
     }
-  enum nss_status status = NSS_STATUS_NOTFOUND;
+  status = NSS_STATUS_NOTFOUND;
   if (res_use_inet6 ())
     status = gethostbyname3_context (ctx, name, AF_INET6, result, buffer,
 				     buflen, errnop, h_errnop, NULL, NULL);
@@ -313,6 +331,9 @@ _nss_dns_gethostbyname4_r (const char *name, struct gaih_addrtuple **pat,
 			   char *buffer, size_t buflen, int *errnop,
 			   int *herrnop, int32_t *ttlp)
 {
+  enum nss_status status = check_name (name, herrnop);
+  if (status != NSS_STATUS_SUCCESS)
+    return status;
   struct resolv_context *ctx = __resolv_context_get ();
   if (ctx == NULL)
     {
@@ -347,7 +368,6 @@ _nss_dns_gethostbyname4_r (const char *name, struct gaih_addrtuple **pat,
   int ans2p_malloced = 0;
 
   int olderr = errno;
-  enum nss_status status;
   int n = __res_context_search (ctx, name, C_IN, T_QUERY_A_AND_AAAA,
 				host_buffer.buf->buf, 2048, &host_buffer.ptr,
 				&ans2p, &nans2p, &resplen2, &ans2p_malloced);
-- 
2.28.0

